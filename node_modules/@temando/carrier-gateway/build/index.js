'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handler = exports.addValidationSchema = exports.getInstrumentationClient = exports.schemaValidator = exports.WebError = undefined;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var validateDocumentAgainstSchemas = function () {
  var _ref = (0, _bluebird.coroutine)(function* (doc, schemas, errorMode) {
    if (!schemas) {
      return doc;
    }

    var validationErrors = yield _bluebird2.default.reduce(schemas, function (data, schema) {
      var result = _schemaValidator2.default.validate(schema, doc);
      if (result.valid) return data;
      return [].concat(_toConsumableArray(data), _toConsumableArray(result.errors.map(function (err) {
        return _extends({}, err, { schema });
      })));
    }, []);

    if (validationErrors.length > 0) {
      throw new WebError(errorMode, validationErrors);
    }

    return doc;
  });

  return function validateDocumentAgainstSchemas(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

var _instrument = require('@temando/instrument');

var _serverlessHelper = require('./lib/serverless-helper');

var _serverlessHelper2 = _interopRequireDefault(_serverlessHelper);

var _schemaValidator = require('./lib/schemaValidator');

var _schemaValidator2 = _interopRequireDefault(_schemaValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WebError = function (_Error) {
  _inherits(WebError, _Error);

  function WebError(status, err) {
    _classCallCheck(this, WebError);

    var errors = Array.isArray(err) ? err : [err];
    var msg = JSON.stringify({ status, errors });
    return _possibleConstructorReturn(this, (WebError.__proto__ || Object.getPrototypeOf(WebError)).call(this, msg));
  }

  return WebError;
}(Error);

var igc = { // Default instrument client
  constructor: function constructor() {},
  log: function log() {},
  emergency: function emergency() {},
  alert: function alert() {},
  critical: function critical() {},
  error: function error() {},
  warning: function warning() {},
  notice: function notice() {},
  info: function info() {},
  debug: function debug() {},
  metric: function metric() {},
  count: function count() {},
  gauge: function gauge() {},
  timing: function timing() {},
  timer: function timer() {},
  timerCommit: function timerCommit() {},
  timerStart: function timerStart() {},
  timerEnd: function timerEnd() {},
  timers: function timers() {},
  timersCommit: function timersCommit() {},
  close: function close() {},
  flush: function flush() {}
};

function getInstrumentationClient() {
  return igc;
}

function processHandler(fn, meta, schemas) {
  return function () {
    var _ref2 = (0, _bluebird.coroutine)(function* (event, context, callback) {
      var method = typeof event.httpMethod !== 'undefined' ? event.httpMethod : 'GET';

      var schemasMatched = schemas[method];
      var response = {};

      if (typeof schemasMatched === 'undefined') {
        schemasMatched = schemas;
      }

      var func = fn;

      if (typeof func !== 'function') {
        func = func[method];
      }

      // console.log('Meta: ', meta);
      // console.log('Schemas: ', schemas);
      //
      // console.log('Event: ', event);
      // console.log('Context:', context);
      // console.log('Callback:', cb);

      // Validate Request
      /* eslint-disable no-console */
      // console.log('Incoming Body:', JSON.stringify(event.body));
      /* eslint-enable no-console */

      if (typeof event.body !== 'undefined' && typeof schemasMatched.requestSchemas !== 'undefined') {
        yield validateDocumentAgainstSchemas(event.body, schemasMatched.requestSchemas, 422);
      }

      if (method === 'GET') {
        response = yield func(event, igc);
      } else if (method === 'POST' || method === 'DELETE' || method === 'PUT' || method === 'PATCH') {
        response = yield func(event.body, igc);
      }

      /* eslint-disable no-console */
      // console.log('Translation Response:', JSON.stringify(response));
      /* eslint-enable no-console */
      yield validateDocumentAgainstSchemas(response, schemasMatched.responseSchemas, 500);

      return response;
    });

    return function (_x4, _x5, _x6) {
      return _ref2.apply(this, arguments);
    };
  }();
}

function addValidationSchema(schemas) {
  return _schemaValidator2.default.addSchemas(schemas);
}

function handler(fn, meta, schemas, instrumentConfig) {
  if (instrumentConfig) {
    igc = new _instrument.InstrumentGatewayClient(instrumentConfig);
  }

  return _serverlessHelper2.default.shimCallback(processHandler(fn, meta, schemas), igc);
}

exports.WebError = WebError;
exports.schemaValidator = _schemaValidator2.default;
exports.getInstrumentationClient = getInstrumentationClient;
exports.addValidationSchema = addValidationSchema;
exports.handler = handler;