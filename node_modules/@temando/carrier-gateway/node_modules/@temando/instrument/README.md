# Metrics and Logs Client and AWS Lambda module

Provides:
 - AWS lambda util to decorate userland Lamda implementation with the client for convenience
 - AWS lambda util to decorate userland Lamda integration with the client for convenience

Supports AWS Lambda Node v4.3.2 and v0.10.42.

## Temando Metrics

See the [Guide to Temando Metrics](https://src.temando.io/project-phoenix/instrumentation-gateway/blob/master/guide_to_temando_metrics.md).
See the [Instrument Gateway Docs](https://src.temando.io/project-phoenix/instrumentation-gateway).

## Installation

Install through npm:

```javascript
npm install @temando/instrument --save
```

__Example__

```javascript
import instrumentation from '@temando/instrument';

// or

import {
  executeLambda,
  instrumentalizeIntegrationLambda
} from '@temando/instrument';
```

**Note:** This library depends on `babel-polyfill`, will need to be imported into the project utilizing it.

## executeLambda Usage

For AWS Lambda usage this is recommended way of using the client.

```javascript
// import it in aws lambda handle file
import { executeLambda } from 'instrument';

module.exports.handler = executeLambda({
    consumerServiceName: 'quote-and-book-service',
    serviceClient: instrumentationServiceClient,
  }, (event, instrumentGatewayClient, callback) => {
    // event aka request in our projects
    // instrumentGatewayClient instance
    // callback - aws lambda one

    // message logs
    // instrumentGatewayClient.log(level, message, context);
    // instrumentGatewayClient.error(message, context);
    // etc

    // metrics logs
    // instrumentGatewayClient.metric(name, metricType, value);
    // instrumentGatewayClient.gauge(name, value)
    // etc

    // when calling some other function or class pass instrumentGatewayClient instance down
    // as dependency. It will benefit you in testing for easy stubbing.
    someHelperFunction(instrumentGatewayClient);
    const objInstance = new Obj(instrumentGatewayClient);
  });
```

This helper replaces `ServerlessHelpers.shimCallback` but has different signature (requires config for the client and passes `instrumentGatewayClient` to the lambda) as seen above.

## executeLambda Usage

For integration Lambdas usage this is the way of using the client:

```javascript
import { instrumentalizeIntegrationLambda } from 'instrument';

module.exports.handler = instrumentalizeIntegrationLambda({
    consumerServiceName: 'quote-and-book-service',
    serviceClient: instrumentationServiceClient,
  }, (document, instrumentGatewayClient) => {
    // this helper passes through to the userland lambda any number of arguments pass to it
    // and injects instrument library instance as the last parameter

    // message logs
    // instrumentGatewayClient.log(level, message, context);
    // instrumentGatewayClient.error(message, context);
    // etc

    // metrics logs
    // instrumentGatewayClient.metric(name, metricType, value);
    // instrumentGatewayClient.gauge(name, value)
    // etc

    // when calling some other function or class pass instrumentGatewayClient instance down
    // as dependency. It will benefit you in testing for easy stubbing.
    someHelperFunction(instrumentGatewayClient);
    const objInstance = new Obj(instrumentGatewayClient);
  });
```
Helper will pass on any number of arguments and will inject instrument client instance as last argument.

## Log Levels

Instrumentation gateway supports the logging levels described by [RFC 5424](http://tools.ietf.org/html/rfc5424).
When logging consider the level of the message as **CRITICAL**, **ALERT**, **EMERGENCY** will generally result in human action.

- **DEBUG**: Detailed debug information.
- **INFO** : Interesting events. Examples: User logs in, SQL logs.
- **NOTICE**: Normal but significant events.
- **WARNING**: Exceptional occurrences that are not errors. Examples:
  Use of deprecated APIs, poor use of an API, undesirable things that are not
  necessarily wrong.
- **ERROR**: Runtime errors that do not require immediate action but
  should typically be logged and monitored.
- **CRITICAL**: Critical conditions. Example: Application component
  unavailable, unexpected exception.
- **ALERT**: Action must be taken immediately. Example: Entire website
  down, database unavailable, etc. This should trigger the SMS alerts and wake
  you up.
- **EMERGENCY**: OMG

## How it works

For performance reasons and total cost of ownership (TCO) __InstrumentGatewayClient__ instance is caching all logs and metrics and flushes them on demand.

For convenience `executeLambda` and `executeIntegrationLambda` decorate Temando userland lambda and passes to it instance of `InstrumentClient` for usage. Single instance should be used in lambda implementation and passed to its' dependencies as a dependency.

`executeLambda` is build as replacement for ServerlessHelper.shimCallback.

`executeIntegrationLambda` is build to accompany integrations that depend on `@temando/carrier-gateway`.

## API

```javascript
// LOGS
instrumentGatewayClient.log(level, message[, context]);

// LOGS (convenience methods)
instrumentGatewayClient.emergency(message[, context]);
instrumentGatewayClient.alert(message[, context]);
instrumentGatewayClient.critical(message[, context]);
instrumentGatewayClient.error(message[, context]);
instrumentGatewayClient.warning(message[, context]);
instrumentGatewayClient.notice(message[, context]);
instrumentGatewayClient.info(message[, context]);
instrumentGatewayClient.debug(message[, context]);

// METRICS
instrumentGatewayClient.metric(type, name, value, context)

// METRICS (convenience methods)
instrumentGatewayClient.count(name, by = 1, context);
instrumentGatewayClient.gauge(name, value, context);
instrumentGatewayClient.timing(name, value, context);

// TIMERS (convenince for timing operations)
instrumentGatewayClient.timerStart(name);
instrumentGatewayClient.timerEnd(name[, additionalName, yetAnotherName...]); // check notes below
const timer = instrumentGatewayClient.timer(name);
instrumentGatewayClient.timerCommit(timer, context);

// close/stop all active timers
instrumentGatewayClient.close(); // @deprecated. It is now expected you correctly manage your timers.

// Posts logs and metrics and resets state
instrumentGatewayClient.flush();
```

Notes:

Additional parameters for `instrumentGatewayClient.timerEnd()` method are used to further segregate timings that share common start time. That way we can track over time more precisely how much time different paths and outcomes take.

Common use case would be measuring how long it takes to run a Temando lambda. e.g.

```javascript
import { instrumentalizeIntegrationLambda } from 'instrument';

module.exports.handler = instrumentalizeIntegrationLambda({
  consumerServiceName: 'quote-and-book-service',
  serviceClient: instrumentationServiceClient,
}, (document, instrumentClient) => {

  instrumentClient.timerStart('quote-and-book-service');

  return callSomeMethod()
    .then(doSomeValidation)
    .catch((error) => {
      instrumentClient.timerEnd('quote-and-book-service.timing', 'validation.failed'); // line C

      return Promise.reject(err);
    })
    .then(callSomeExternalService)
    .then((result) => {
      instrumentClient.timerEnd('quote-and-book-service.timing', 'quote-and-book-service.succeeded'); // line A

      // success
      return result;
    })
    .catch((error) => {
      instrumentClient.timerEnd('quote-and-book-service.timing', 'external-service-name.action.failed'); // line B

      // failure
      return Promise.reject(error);
    });
});
```
Calls listed above would make following metric calls:
```javascript
  // line A would log time under: 'quote-and-book-service.timing' and 'quote-and-book-service.succeeded'
  // line B would log time under: 'quote-and-book-service.timing' and 'external-service-name.action.failed'
  // line C would log time under: 'quote-and-book-service.timing' and 'validation.failed'
```

### Examples

The examples below are not definitive but can be used to help you get started.

Please change string values and context objects and other settings where required.

#### Logs

```javascript
// Level and message set for 'info' log
instrumentGatewayClient.info('Sending request', { requestBody: request });
```

#### Metrics

```javascript
// Type, name and value set for metric
instrumentGatewayClient.metric('count', `Request ${document.integrationId}`, 1);

// Count convenience method
instrumentGatewayClient.count(`Request ${document.integrationId}`, 1);

// Timing convenience method
const serviceTimer = instrumentGatewayClient.timer('Request to service');
instrumentGatewayClient.timerCommit(serviceTimer);
```

### Creating a service client

Assuming your project is [service registry aware](https://src.temando.io/service-registry). The
[service client factory](https://src.temando.io/service-registry/service-client-factory) can conveniently construct
a service client for the instrumentation client to use to communicate with the instrumentation gateway service.

```javascript
import * as instrument from '@temando/instrument';
import ServiceClientFactory from '@temando/service-client-factory';
import yourServiceHandler from '../src/yourServiceHandler';

const scf = new ServiceClientFactory();

module.exports.handler = instrument.executeLambda({
  consumerServiceName: 'your-service-handler', // required
  serviceClient: scf.createServiceClient('temando-instrumentation-client'), // required
}, yourServiceHandler);
```

You can then start to use the Instrument Library to log and capture metrics. See the example below:

```javascript
function yourServiceHandler(request, instrumentGatewayClient, callback) {
  const queuedRequests = [...];

  instrumentGatewayClient.timerStart('Queued requests');

  Promise.all(queuedRequests).then((responses) => {
    instrumentGatewayClient.timerEnd('Queued requests');
    callback(null, response);
  }).catch((err) => {
    instrumentGatewayClient.log('error', 'Received error', JSON.stringify(err));
    instrumentGatewayClient.timerEnd('Queued requests');
    callback(JSON.stringify({ status: 500, errors: err }));
  });
}
```

To make sure everything works in your project and if you are using library correctly check Clould Watch logs on receiveing end, Instrument Gateway.

### Testing

By default, the Instrument Library will console log all methods that are called. This can make reading the results of tests hard. To disable this output, set the environment to test mode.

```javascript
"scripts": {
    "...",
    "test": "NODE_ENV=test ..."
  },
```
