'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _DatadogLogMetrics = require('./plugins/DatadogLogMetrics');

var _DatadogLogMetrics2 = _interopRequireDefault(_DatadogLogMetrics);

var _CollectLogMetrics = require('./plugins/CollectLogMetrics');

var _CollectLogMetrics2 = _interopRequireDefault(_CollectLogMetrics);

var _LogToConsole = require('./plugins/LogToConsole');

var _LogToConsole2 = _interopRequireDefault(_LogToConsole);

var _FlushToGateway = require('./plugins/FlushToGateway');

var _FlushToGateway2 = _interopRequireDefault(_FlushToGateway);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Logs statements so they are pretty in AWS Cloudwatch Logs.
 *
 * @deprecated left over because of InstrumentGatewayClient::close(), which is deprecated.
 *
 * @param args
 */
function consoleLog() {
  const isTestsEnv = process.env.NODE_ENV && process.env.NODE_ENV.toLowerCase() === 'test';
  if (isTestsEnv) {
    return;
  }

  /* eslint-disable no-console */

  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  console.log((0, _stringify2.default)(args));
  /* eslint-enable no-console */
}

/**
 * hrtime to microseconds
 *
 * It will also always round up to nearest μs.
 *
 * @param hrtime
 * @returns number
 */
function hrTimeToMicroseconds(hrtime) {
  return Math.ceil(hrtime[0] * 1000000 + hrtime[1] / 1000);
}

const logLevels = ['emergency', 'alert', 'critical', 'error', 'warning', 'notice', 'info', 'debug'];

const metricTypes = ['count', 'gauge', 'timing'];

/**
 * The Client.
 */
class InstrumentGatewayClient {

  /**
   * Create a new client.
   *
   * @param {Object} config
   */


  // Metric Schema


  // Metric Name Schema
  constructor(config) {
    this.metricNameSchema = _joi2.default.string().regex(/^[-a-zA-Z0-9.]+$/).example('invocation-count');
    this.accountSchema = _joi2.default.string().regex(/^[-a-zA-Z0-9]+$/);
    this.codeSchema = _joi2.default.string().regex(/^[a-zA-Z0-9]+$/);
    this.logSchema = _joi2.default.object().keys({
      level: _joi2.default.string().only(logLevels),
      message: _joi2.default.string(),
      context: _joi2.default.object().keys({
        account: this.accountSchema,
        code: this.codeSchema
      }).unknown()
    }).requiredKeys('message').optionalKeys('context');
    this.metricSchema = _joi2.default.object().keys({
      type: _joi2.default.string().only(metricTypes),
      name: this.metricNameSchema,
      value: _joi2.default.number().integer(),
      context: _joi2.default.object().keys({
        account: this.accountSchema,
        code: this.codeSchema
      }).unknown()
    });
    this.timingSchema = this.metricSchema.requiredKeys('name', 'value').optionalKeys('context');
    this.gaugeSchema = this.metricSchema.requiredKeys('name', 'value').optionalKeys('context');
    this.countSchema = this.metricSchema.requiredKeys('name', 'value').optionalKeys('context');

    const errorPrefix = 'InstrumentGatewayClient config';

    if (!config) {
      throw new Error(`${ errorPrefix } must be provided`);
    }

    if (typeof config.consumerServiceName !== 'string') {
      throw new Error(`${ errorPrefix } consumerServiceName is required (typeof string)`);
    }

    this.consumerServiceName = config.consumerServiceName;

    if (typeof config.serviceClient === 'undefined') {
      throw new Error(`${ errorPrefix } serviceClient is required (typeof string)`);
    }

    this.serviceClient = config.serviceClient;

    this.test = process.env.NODE_ENV && process.env.NODE_ENV.toLowerCase() === 'test';

    this.events = new _events2.default();

    this.plugins = [];

    if (typeof config.skipLogMetrics === 'undefined') {
      this.plugins.push(new _CollectLogMetrics2.default(this.events, this));
    }

    if (!this.test) {
      this.plugins.push(new _LogToConsole2.default(this.events));
      this.plugins.push(new _DatadogLogMetrics2.default(this.events));
    }

    // This is the last plugin that should register, as it reads data.
    this.plugins.push(new _FlushToGateway2.default(this.events, this.serviceClient));

    this.metricsData = [];
    this.logsData = [];
    this.timeStarts = {};
  }

  // LOGGING RELATED

  /**
   * Log a message.
   *
   * @param {String} level
   * @param {String} message
   * @param {Object} contextData
   * @return {InstrumentGatewayClient}
   */


  // Log Schema


  // Account Schema
  log(level, message, context) {
    const params = { level: level, message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) throw validationResult.error;

    const requestBody = {
      origin: this.consumerServiceName,
      level: level,
      message: message,
      context: context,
      occurredAt: new Date().toISOString()
    };

    this.logsData.push(requestBody);

    this.events.emit('log', requestBody);

    return this;
  }

  /**
   * Log an emergency message.
   *
   * @param {String} message
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  emergency(message, context) {
    const params = { message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }

    this.log('emergency', message, context);

    return this;
  }

  /**
   * Log an alert message.
   *
   * @param {String} message
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  alert(message, context) {
    const params = { message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }

    this.log('alert', message, context);

    return this;
  }

  /**
   * Log a critical message.
   *
   * @param {String} message
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  critical(message, context) {
    const params = { message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }

    this.log('critical', message, context);

    return this;
  }

  /**
   * Log an error message.
   *
   * @param {String} message
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  error(message, context) {
    const params = { message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }

    this.log('error', message, context);

    return this;
  }

  /**
   * Log a warning message.
   *
   * @param {String} message
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  warning(message, context) {
    const params = { message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }

    this.log('warning', message, context);

    return this;
  }

  /**
   * Log a notice message.
   *
   * @param {String} message
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  notice(message, context) {
    const params = { message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }
    this.log('notice', message, context);

    return this;
  }

  /**
   * Log an info message.
   *
   * @param {String} message
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  info(message, context) {
    const params = { message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }
    this.log('info', message, context);

    return this;
  }

  /**
   * Log a debug message.
   *
   * @param {String} message
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  debug(message, context) {
    const params = { message: message, context: context };
    const validationResult = _joi2.default.validate(params, this.logSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }
    this.log('debug', message, context);

    return this;
  }

  // METRICS RELATED

  /**
   * Add a new metric to collection.
   *
   * @param {String} type
   * @param {String} name
   * @param {String} value
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  metric(type, name, value, context) {
    const params = { type: type, name: name, value: value, context: context };
    const validationResult = _joi2.default.validate(params, this.metricSchema.requiredKeys('type', 'name', 'value'));
    if (validationResult.error) {
      throw validationResult.error;
    }

    const requestBody = {
      name: name,
      origin: this.consumerServiceName,
      occurredAt: new Date().toISOString(),
      context: context || {}
    };

    switch (type) {
      case 'count':
        requestBody.increment = value;
        break;
      case 'gauge':
        requestBody.gauge = value;
        break;
      case 'timing':
        requestBody.timing = value;
        break;
      default:
    }

    this.metricsData.push(requestBody);
    this.events.emit('metric', requestBody);

    return this;
  }

  /**
   * Add count metric to collection.
   *
   * @param {String} name
   * @param {Integer} by
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  count(name) {
    let by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let context = arguments[2];

    const params = { name: name, value: by, context: context };
    const validationResult = _joi2.default.validate(params, this.countSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }

    this.metric('count', name, by, context);

    return this;
  }

  /**
   * Add gauge metric to collection.
   *
   * @param {Object} param The gauge object
   * @param {String} param.name The gauge name
   * @param {String} integer
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  gauge(name, value, context) {
    const params = { name: name, value: value, context: context };
    const validationResult = _joi2.default.validate(params, this.gaugeSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }

    this.metric('gauge', name, value, context);

    return this;
  }

  /**
   * Add timing metric to collection.
   *
   * @param {String} name
   * @param {Integer} value A timing in microseconds (μs).
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  timing(name, value, context) {
    const params = { name: name, value: value, context: context };
    const validationResult = _joi2.default.validate(params, this.timingSchema);
    if (validationResult.error) {
      throw validationResult.error;
    }

    this.metric('timing', name, value, context);

    return this;
  }

  /**
   * Creates a timer.
   *
   * @see this.timers().
   *
   * @param {String} action
   * @returns {Array.<Timer>}
   */
  timer(action) {
    // eslint-disable-line class-methods-use-this
    return this.timers([action]).shift();
  }

  /**
   * Commit a timer to instrumentation.
   *
   * @param {Timer} timer
   * @param {Object} context
   * @return {InstrumentGatewayClient}
   */
  timerCommit(timer, context) {
    return this.timersCommit([(0, _extends3.default)({}, timer, { context: context })]);
  }

  /**
   * Start a timer with metric name.
   *
   * @deprecated It's not recommended to use this function. Use self::timer() instead.
   * @param {String} name
   * @return {InstrumentGatewayClient}
   */
  timerStart(name) {
    if (typeof this.timeStarts[name] === 'number') {
      throw new Error(`Start time for ${ name } already exists`);
    }

    this.timeStarts[name] = process.hrtime();

    return this;
  }

  /**
   * End a timer with metric name. This method can also accept further list of
   * metric timers to commit based on the timing of the original timer.
   *
   * @param {String} name
   * @param {...String} additionalNames
   * @return {InstrumentGatewayClient}
   */
  timerEnd(name) {
    if (typeof this.timeStarts[name] !== 'object') {
      throw new Error(`Start time for ${ name } is not defined`);
    }

    const startTime = this.timeStarts[name];
    delete this.timeStarts[name];
    const timing = hrTimeToMicroseconds(process.hrtime(startTime));

    this.timing(name, timing);

    for (var _len2 = arguments.length, additionalNames = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      additionalNames[_key2 - 1] = arguments[_key2];
    }

    additionalNames.forEach(additionalName => this.timing(additionalName, timing));

    return this;
  }

  /**
   * Returns an array of timers.
   *
   * This requires the programmer to keep their timers in scope.
   * It gets around the problem of the same action overwriting each other in the timeStarts
   * array, and thus giving false timings.
   *
   * @param {Array.<String>} actions
   * @returns {Array.<Timer>}
   */
  timers(actions) {
    // eslint-disable-line class-methods-use-this
    return actions.map(action => {
      if (typeof action !== 'string') {
        throw new TypeError('Given action should be of string type');
      }

      return { action: action, startTime: process.hrtime() };
    });
  }

  /**
   * Commits an array of timers to instrumentation.
   *
   * @param [Timer] timers
   * @return {InstrumentGatewayClient}
   */
  timersCommit(timers) {
    timers.forEach(timer => {
      const μs = hrTimeToMicroseconds(process.hrtime(timer.startTime));

      return this.timing(timer.action, μs, timer.context);
    });

    return this;
  }

  /**
   * Close any unterminated timers.
   *
   * @deprecated this is being used a catch all shutdown of the lib...
   *             The lib should not be used this way.
   *
   * @return {InstrumentGatewayClient}
   */
  close() {
    try {
      const timers = (0, _keys2.default)(this.timeStarts);
      if (timers.length) {
        consoleLog('WARNING: The request is being terminated with unterminated timers', timers);
      }

      timers.forEach(metric => {
        consoleLog('close.metric', metric);

        this.timerEnd(metric);
      });
    } catch (error) {
      consoleLog('InstrumentGatewayClient.closetiming(()', error);
    }

    return this;
  }

  /**
   * This sends all logs and completed metrics to the instrument
   * gateway. Incomplete timers are not yet in metricsData property and will
   * not be sent until the timer is stopped.
   *
   * @return {InstrumentGatewayClient}
   */
  flush() {
    this.events.emit('flushLogs', this.logsData);
    this.logsData = [];

    this.events.emit('flushMetrics', this.metricsData);
    this.metricsData = [];

    return this;
  }
}
exports.default = InstrumentGatewayClient;
module.exports = exports['default'];