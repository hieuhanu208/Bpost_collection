"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventEmitter = require("events");
const Joi = require("joi");
const lib_1 = require("./lib");
const DatadogLogMetrics_1 = require("./plugins/DatadogLogMetrics");
const LogToConsole_1 = require("./plugins/LogToConsole");
const logLevels = [
    'emergency',
    'alert',
    'critical',
    'error',
    'warning',
    'notice',
    'info',
    'debug',
];
const metricTypes = ['count', 'gauge', 'histogram', 'timing'];
/**
 * The Client.
 */
class InstrumentClient extends EventEmitter {
    /**
     * Create a new client.
     *
     * @param {Object} config
     */
    constructor({ consumerServiceName }) {
        super();
        this.plugins = [];
        this.metricsData = [];
        this.logsData = [];
        this.tags = {};
        // Metric Name Schema
        this.metricNameSchema = Joi.string().regex(/^[-a-zA-Z0-9.]+$/).example('invocation-count');
        // Account Schema
        this.accountSchema = Joi.string().regex(/^[-a-zA-Z0-9]+$/);
        this.codeSchema = Joi.string().regex(/^[a-zA-Z0-9]+$/);
        // Log Schema
        this.logSchema = Joi.object().keys({
            level: Joi.string().only(logLevels),
            message: Joi.string(),
            context: Joi.object().keys({
                account: this.accountSchema,
                code: this.codeSchema,
            }).unknown(),
        }).requiredKeys('message').optionalKeys('context');
        // Metric Schema
        this.metricSchema = Joi.object().keys({
            type: Joi.string().only(metricTypes),
            name: this.metricNameSchema,
            value: Joi.number(),
            context: Joi.object().keys({
                account: this.accountSchema,
                code: this.codeSchema,
            }).unknown(),
        });
        this.histogramSchema = this.metricSchema.requiredKeys('name', 'value').optionalKeys('context');
        this.gaugeSchema = this.metricSchema.requiredKeys('name', 'value').optionalKeys('context');
        this.countSchema = this.metricSchema.requiredKeys('name', 'value').optionalKeys('context');
        this.tagSchema = Joi.array().items(Joi.string().regex(/^[a-z0-9_-]+$/i)).length(2);
        if (!consumerServiceName) {
            throw new Error(`consumerServiceName is required`);
        }
        this.consumerServiceName = consumerServiceName;
        this.test = (process.env.NODE_ENV && process.env.NODE_ENV.toLowerCase() === 'test');
        if (!this.test) {
            this.plugins.push(new LogToConsole_1.default(this));
            this.plugins.push(new DatadogLogMetrics_1.default(this));
        }
    }
    /**
     * Add a global tag which will be attached to all future messages.
     */
    tag(key, value) {
        lib_1.validate([key, value], this.tagSchema);
        this.tags[key] = value;
        return this;
    }
    log(...args) {
        const { level, message, context, tags } = lib_1.parseArguments(args, ['level', 'message', 'context', 'tags']);
        lib_1.validate({ level, message, context }, this.logSchema);
        const requestBody = {
            origin: this.consumerServiceName,
            level,
            message,
            context,
            occurredAt: new Date().toISOString(),
        };
        this.logsData.push(requestBody);
        this.emit('log', requestBody, Object.assign({}, this.tags, tags || {}));
        return this;
    }
    emergency(...args) {
        const { message, context, tags } = lib_1.parseArguments(args, ['message', 'context', 'tags']);
        return this.log('emergency', message, context, tags);
    }
    alert(...args) {
        const { message, context, tags } = lib_1.parseArguments(args, ['message', 'context', 'tags']);
        return this.log('alert', message, context, tags);
    }
    critical(...args) {
        const { message, context, tags } = lib_1.parseArguments(args, ['message', 'context', 'tags']);
        return this.log('critical', message, context, tags);
    }
    error(...args) {
        const { message, context, tags } = lib_1.parseArguments(args, ['message', 'context', 'tags']);
        return this.log('error', message, context, tags);
    }
    warning(...args) {
        const { message, context, tags } = lib_1.parseArguments(args, ['message', 'context', 'tags']);
        return this.log('warning', message, context, tags);
    }
    notice(...args) {
        const { message, context, tags } = lib_1.parseArguments(args, ['message', 'context', 'tags']);
        return this.log('notice', message, context, tags);
    }
    info(...args) {
        const { message, context, tags } = lib_1.parseArguments(args, ['message', 'context', 'tags']);
        return this.log('info', message, context, tags);
    }
    debug(...args) {
        const { message, context, tags } = lib_1.parseArguments(args, ['message', 'context', 'tags']);
        return this.log('debug', message, context, tags);
    }
    metric(...args) {
        const { type, name, value, context, tags } = lib_1.parseArguments(args, ['type', 'name', 'value', 'context', 'tags']);
        lib_1.validate({ type, name, value, context }, this.metricSchema.requiredKeys('type', 'name', 'value'));
        const requestBody = {
            name,
            origin: this.consumerServiceName,
            occurredAt: new Date().toISOString(),
            context: context || {},
        };
        switch (type) {
            case 'count':
                requestBody.increment = value;
                break;
            case 'gauge':
                requestBody.gauge = value;
                break;
            case 'timing':
            case 'histogram':
                requestBody.histogram = value;
                break;
            default:
        }
        this.metricsData.push(requestBody);
        this.emit('metric', requestBody, Object.assign({}, this.tags, tags || {}));
        return this;
    }
    count(...args) {
        const { name, value = 1, context, tags } = lib_1.parseArguments(args, ['name', 'value', 'context', 'tags']);
        lib_1.validate({ name, value, context }, this.countSchema);
        return this.metric('count', name, value, context, tags);
    }
    gauge(...args) {
        const { name, value, context, tags } = lib_1.parseArguments(args, ['name', 'value', 'context', 'tags']);
        lib_1.validate({ name, value, context }, this.gaugeSchema);
        return this.metric('gauge', name, value, context, tags);
    }
    histogram(...args) {
        const { name, value, context, tags } = lib_1.parseArguments(args, ['name', 'value', 'context', 'tags']);
        lib_1.validate({ name, value, context }, this.histogramSchema);
        return this.metric('histogram', name, value, context, tags);
    }
    timing(...args) {
        const { name, value, context, tags } = lib_1.parseArguments(args, ['name', 'value', 'context', 'tags']);
        let timing = value;
        if (lib_1.isTimer(value)) {
            timing = lib_1.hrTimeToMicroseconds(process.hrtime(value.start));
        }
        return this.histogram(name, timing, context, tags);
    }
    /**
     * Creates a timer.
     *
     * Give it to timing() when it's time to commit.
     */
    timer() {
        return { start: process.hrtime() };
    }
}
exports.InstrumentClient = InstrumentClient;
//# sourceMappingURL=InstrumentClient.js.map