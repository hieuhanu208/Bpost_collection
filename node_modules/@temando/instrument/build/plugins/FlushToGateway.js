'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 1000 is the maximum amount of logs, or metrics allowed in a singular message.
const defaultLogBatchSize = 1000;
const defaultMetricsBatchSize = 1000;

/**
 * Chunks a given array in to batchSize chunks.
 *
 * @param {Array} array
 * @param {number} batchSize
 */
function* chunk(array, batchSize) {
  if (array && array.length > 0) {
    let startIndex = 0;

    do {
      yield array.slice(startIndex, startIndex + batchSize);
      startIndex += batchSize;
    } while (startIndex < array.length);
  }
}

/**
 * Format a message for AWS SQS.
 */
function createQueueMessage(message) {
  let payload;

  if (message === undefined || message === '') {
    throw new Error('No message sent');
  }

  if (typeof message === 'string') {
    payload = message;
  } else {
    payload = (0, _stringify2.default)(message);
  }

  return {
    MessageBody: payload,
    DelaySeconds: 0
  };
}

/**
 * Gets instrumentation data into the gateway ingest queue.
 */
class FlushToGateway {
  constructor(events, serviceClient, config) {
    config = config || {};

    const logBatchSize = config.logBatchSize || defaultLogBatchSize;
    const metricsBatchSize = config.metricsBatchSize || defaultMetricsBatchSize;

    function pushToQueue(data, batchSize) {
      for (const batch of chunk(data, batchSize)) {
        serviceClient.enqueue('ingest', createQueueMessage(batch));
      }
    }

    events.on('flushLogs', logs => {
      pushToQueue(logs, logBatchSize);
    });

    events.on('flushMetrics', metrics => {
      pushToQueue(metrics, metricsBatchSize);
    });
  }
}
exports.default = FlushToGateway;
module.exports = exports['default'];
