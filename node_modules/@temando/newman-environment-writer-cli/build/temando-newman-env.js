#!/usr/bin/env node
'use strict';

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _awsSdk = require('aws-sdk');

var _awsSdk2 = _interopRequireDefault(_awsSdk);

var _commander = require('commander');

var _commander2 = _interopRequireDefault(_commander);

var _serviceRegistryLib = require('@temando/service-registry-lib');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/**
 * Read a file from the given path and return the contents.
 *
 * @throws {Error} If file could not be read
 * @param  {String} filePath
 * @return {Mixed}
 */
function readJSONFile(filePath) {
  try {
    return JSON.parse(_fs2.default.readFileSync(filePath, {
      encoding: 'utf-8'
    }));
  } catch (error) {
    throw new Error(`Could not open JSON file "${filePath}", error: ${error.message}`);
  }
}

/**
 * Given a Postman environment, a service catalog entry and possibly the region,
 * replace any variables with actual values from the service and return the
 * populated environment.
 *
 * @throws {Error} If environment file is invalid, or deployment information is missing
 * @param  {Object} environment
 * @param  {Object} catalogEntry
 * @param  {Object} awsCredentials
 * @param  {String} region
 * @return {Object}
 */
function populateEnvironment(environment, catalogEntry, awsCredentials, region) {
  if (environment.hasOwnProperty('values') === false) {
    throw new Error('Given environment is invalid, missing "values" property.');
  }

  const populatedEnv = JSON.parse(JSON.stringify(environment));
  const deployment = region ? catalogEntry.deployments.find(service => service.region === region) : catalogEntry.deployments[0];

  if (!deployment) {
    let message = `No deployment information found for ${catalogEntry.definition.id}`;

    if (region) {
      message += ` in region ${region}.`;
    } else {
      message += '.';
    }

    throw new Error(message);
  }

  let credentials;
  if (typeof awsCredentials.accessKeyId !== 'undefined') {
    credentials = awsCredentials;
  } else {
    console.info(`No aws credential information found for ${awsCredentials.profile}`);
  }

  // Loop over the environment file, replacing any values that match.
  populatedEnv.values = environment.values.map(variable => {
    const populatedVariable = JSON.parse(JSON.stringify(variable));

    if (deployment && typeof deployment[populatedVariable.key] !== 'undefined') {
      populatedVariable.value = deployment[populatedVariable.key];
    } else if (credentials && typeof credentials[populatedVariable.key] !== 'undefined') {
      populatedVariable.value = credentials[populatedVariable.key];
    }

    return populatedVariable;
  });

  return populatedEnv;
}

_commander2.default.option('-e, --env <env>', 'the environment the registry is', 'dev').option('-m, --mode <mode>', 'set the mode, s3 or local', 's3');

_commander2.default.command('write <environment>').option('-o, --output <output>', 'path where the environment should be written, defaults to replacing existing environment').option('-d, --definition <definition>', 'path to the service definition', 'ts-definition.json').option('-r, --region <region>', 'when specified, will look for a deployment information in this AWS region').description('takes a Postman environment and populates it with service information').action((() => {
  var _ref = _asyncToGenerator(function* (environmentPath, options) {
    const r = new _serviceRegistryLib.Registry(_commander2.default.env, _commander2.default.mode);
    const environmentFilePath = `${process.cwd()}/${environmentPath}`;
    const definitionFilePath = `${process.cwd()}/${options.definition}`;
    const region = options.region;

    let outputFilePath = environmentFilePath;

    try {
      // Get files
      const environment = readJSONFile(environmentFilePath);
      const definition = readJSONFile(definitionFilePath);

      // Get service definition from catalog for deployment info
      const entry = yield r.catalog().get(definition.id);

      // Get AWS credentials from shared using env
      const credentials = new _awsSdk2.default.SharedIniFileCredentials({ profile: _commander2.default.env });

      // Populate it
      const populatedEnvironment = populateEnvironment(environment, entry, credentials, region);

      // Write it
      if (options.output !== undefined) {
        outputFilePath = options.output;
      }

      _fs2.default.writeFileSync(outputFilePath, JSON.stringify(populatedEnvironment, null, 2));
      console.info(`Environment written to ${outputFilePath}`);
    } catch (error) {
      console.error(error.message);
      console.info(error.stack);
      process.exit(1);
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
})());

_commander2.default.parse(process.argv);