/**
 * PackageMate extends Temando generic package object that and allows one to
 * normalize its weight and dimension units to a variety of other metrics. It
 * takes a package as an argument, clones the object then augments it with some
 * convenience methods for performing weight/dimension conversion.
 *
 * @author    Jason Wijegooneratne <jason.wijegooenratne@temando.com>
 * @date      14-June-2016
 * @copyright Temando Pty Ltd
 */

import convert from 'convert-units';
import clone from 'clone';

// Pollyfill array includes method if required.
if (!Array.prototype.includes) {
  Array.prototype.includes = function (searchElement, ...args) {
    const O = Object(this);
    const len = parseInt(O.length, 10) || 0;
    const n = parseInt(args[1], 10) || 0;
    let k;
    let currentElement;

    if (len === 0) {
      return false;
    }

    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) { k = 0; }
    }

    while (k < len) {
      currentElement = O[k];
      if (searchElement === currentElement ||
          (searchElement !== searchElement && currentElement
           !== currentElement)) { // NaN !== NaN
        return true;
      }
      k++;
    }
    return false;
  };
}

/**
 * Takes a temando package and augments it with some helper methods.
 *
 * @param {object} aPackage - A temando package object literal.
 * @returns {object} An augmented temando package object literal.
 */
export default function packageMate(aPackage) {
  const r = {};
  const pkg = clone(aPackage, true);

  pkg.normaliseDimensions = function (metric) {
    if (pkg.hasOwnProperty('dimensions')) {
      try {
        const baseUnit = r.normaliseDimensionMetric(pkg.dimensions.unit);
        const conversionUnit = r.normaliseDimensionMetric(metric);

        pkg.dimensions.length = parseFloat(convert(pkg.dimensions.length)
                                      .from(baseUnit)
                                      .to(conversionUnit)
                                      .toFixed(2));

        pkg.dimensions.width = parseFloat(convert(pkg.dimensions.width)
                                          .from(baseUnit)
                                          .to(conversionUnit)
                                          .toFixed(2));

        pkg.dimensions.height = parseFloat(convert(pkg.dimensions.height)
                                           .from(baseUnit)
                                           .to(conversionUnit)
                                           .toFixed(2));

        pkg.dimensions.unit = metric;
      } catch (e) {
        throw new Error('Some elements in the dimensions set are missing');
      }
    } else {
      throw new Error('Package object does not have its dimensions set');
    }

    return pkg;
  };

  r.normaliseDimensionMetric = function (metric) {
    const metrics = [{ unit: ['mm', 'millimeter', 'millimetre'], map: 'mm' },
                     { unit: ['cm', 'centimeter', 'centimetre'], map: 'cm' },
                     { unit: ['m', 'meter', 'metre'], map: 'm' },
                     { unit: ['ft', 'foot', 'feet'], map: 'ft' },
                     { unit: ['in', 'inch'], map: 'in' },
                     { unit: ['yd', 'yard'], map: 'yd' }];
    let conversion = false;

    metrics.forEach((m) => {
      if (m.unit.includes(metric.toLowerCase())) {
        conversion = m.map;
      }
    });

    if (conversion === false) {
      throw new Error(`unknown dimension metric: ${metric}`);
    }

    return conversion;
  };

  pkg.normaliseWeight = function (metric) {
    if (pkg.hasOwnProperty('grossWeight')) {
      if (!pkg.grossWeight.unit) {
        throw new Error('Weight unit is required');
      }
      const baseUnit = r.normaliseWeightMetric(pkg.grossWeight.unit);
      const conversionUnit = r.normaliseWeightMetric(metric);

      pkg.grossWeight.amount = parseFloat(convert(pkg.grossWeight.amount)
                                          .from(baseUnit)
                                          .to(conversionUnit));

      pkg.grossWeight.unit = metric;
    } else {
      throw new Error('Package object does not have its grossWeight set');
    }

    return pkg;
  };

  r.normaliseWeightMetric = function (metric) {
    const metrics = [{ unit: ['g', 'gram'], map: 'g' },
                     { unit: ['kg', 'kilogram'], map: 'kg' },
                     { unit: ['lb', 'pound'], map: 'lb' },
                     { unit: ['oz', 'ounce'], map: 'oz' }];

    let conversion = false;

    metrics.forEach((m) => {
      if (m.unit.includes(metric.toLowerCase())) {
        conversion = m.map;
      }
    });

    if (conversion === false) {
      throw new Error(`unknown weight metric: ${metric}`);
    }

    return conversion;
  };

  return pkg;
}
