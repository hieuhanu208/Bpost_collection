"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const service_registry_lib_1 = require("@temando/service-registry-lib");
const service_client_factory_1 = require("@temando/service-client-factory");
const sinon = require("sinon");
const Integration_1 = require("./../Integration");
describe('Integration', () => {
    const definitionId = 'carrier-integration-stub';
    const endpoint = 'https://abcdefghij.execute-api.eu-west-1.amazonaws.com/dev';
    let logStub;
    let registryStub;
    let catalogStub;
    beforeEach(() => {
        catalogStub = sinon.stub();
        registryStub = sinon.createStubInstance(service_registry_lib_1.Registry);
        logStub = sinon.stub();
    });
    describe('getDeployment', () => __awaiter(this, void 0, void 0, function* () {
        it('gets a deployment', () => __awaiter(this, void 0, void 0, function* () {
            const expectedDeployment = {
                region: 'eu-west-1',
                endpoint,
            };
            catalogStub
                .withArgs(definitionId)
                .returns(Promise.resolve({
                deployments: [expectedDeployment],
            }));
            registryStub
                .catalog
                .withArgs()
                .onFirstCall()
                .returns({
                get: catalogStub,
            });
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            const deployment = yield integration.getDeployment('eu-west-1');
            expect(deployment).toEqual(expectedDeployment);
        }));
        it('throws an error if catalog get throws an error', () => __awaiter(this, void 0, void 0, function* () {
            catalogStub
                .withArgs(definitionId)
                .returns(Promise.reject(new Error('is broken')));
            registryStub
                .catalog
                .withArgs()
                .onFirstCall()
                .returns({
                get: catalogStub,
            });
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            yield expect(integration.getDeployment('eu-west-1'))
                .rejects
                .toMatchObject({
                message: 'Error: is broken',
            });
        }));
        it('throws an error no deployments found', () => __awaiter(this, void 0, void 0, function* () {
            catalogStub
                .withArgs(definitionId)
                .returns(Promise.resolve({
                deployments: [],
            }));
            registryStub
                .catalog
                .withArgs()
                .onFirstCall()
                .returns({
                get: catalogStub,
            });
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            yield expect(integration.getDeployment('eu-west-1'))
                .rejects
                .toMatchObject({
                message: 'No deployment information found for carrier-integration-stub',
            });
        }));
        it('throws an error if no matching deployment found', () => __awaiter(this, void 0, void 0, function* () {
            const expectedDeployment = {
                region: 'ap-northeast-2',
                endpoint,
            };
            catalogStub
                .withArgs(definitionId)
                .returns(Promise.resolve({
                deployments: [expectedDeployment],
            }));
            registryStub
                .catalog
                .withArgs()
                .onFirstCall()
                .returns({
                get: catalogStub,
            });
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            yield expect(integration.getDeployment('eu-west-1'))
                .rejects
                .toMatchObject({
                message: 'No deployment information found for carrier-integration-stub',
            });
        }));
    }));
    describe('generatePayload', () => __awaiter(this, void 0, void 0, function* () {
        it('generates a payload', () => __awaiter(this, void 0, void 0, function* () {
            const expectedDeployment = {
                region: 'eu-west-1',
                endpoint,
            };
            catalogStub
                .withArgs(definitionId)
                .returns(Promise.resolve({
                deployments: [expectedDeployment],
            }));
            registryStub
                .catalog
                .withArgs()
                .onFirstCall()
                .returns({
                get: catalogStub,
            });
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            const integrationDetails = {
                integrationDetails: 'some integration deets',
            };
            const marcoDetails = {
                marcoDetails: 'some marco deets',
            };
            serviceClientStub
                .request
                .withArgs(`/integrations/${definitionId}/integration`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.resolve({
                status: 200,
                json: () => __awaiter(this, void 0, void 0, function* () { return integrationDetails; }),
            }));
            serviceClientStub
                .request
                .withArgs(`/integrations/${definitionId}/integration/marco`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.resolve({
                status: 200,
                json: () => __awaiter(this, void 0, void 0, function* () { return marcoDetails; }),
            }));
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            const result = yield integration.generatePayload(serviceClientStub, endpoint);
            expect(result).toEqual({
                data: {
                    type: 'carrier-integration',
                    attributes: {
                        integration: { integrationDetails: 'some integration deets' },
                        marco: { marcoDetails: 'some marco deets' },
                        endpoint,
                    },
                },
            });
        }));
        it('bubbles up error if encountered', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            serviceClientStub
                .request
                .withArgs(`/integrations/${definitionId}/integration`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.reject(new Error('is broken')));
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            yield expect(integration.generatePayload(serviceClientStub, endpoint))
                .rejects
                .toMatchObject({
                message: 'Error: is broken',
            });
        }));
    }));
    describe('getIntegrationDetails', () => __awaiter(this, void 0, void 0, function* () {
        it('gets integration details', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            const integrationDetails = {
                integrationDetails: 'some integration deets',
            };
            serviceClientStub
                .request
                .withArgs(`/integrations/${definitionId}/integration`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.resolve({
                status: 200,
                json: () => __awaiter(this, void 0, void 0, function* () { return integrationDetails; }),
            }));
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            const result = yield integration.getIntegrationDetails(serviceClientStub);
            expect(result).toEqual(integrationDetails);
        }));
        it('bubbles up error if encountered', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            serviceClientStub
                .request
                .withArgs(`/integrations/${definitionId}/integration`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.reject(new Error('is broken')));
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            yield expect(integration.getIntegrationDetails(serviceClientStub))
                .rejects
                .toMatchObject({
                message: 'Error: is broken',
            });
        }));
        it('throws error if non-200 status received', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            serviceClientStub
                .request
                .withArgs('/integrations/carrier-integration-stub/integration', {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.resolve({
                status: 400,
                json: () => __awaiter(this, void 0, void 0, function* () { return ({ fail: 'broken' }); }),
            }));
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            yield expect(integration.getIntegrationDetails(serviceClientStub))
                .rejects
                .toMatchObject({
                message: 'Error retrieving integration details: {"fail":"broken"}',
            });
        }));
    }));
    describe('getMarcoDetails', () => __awaiter(this, void 0, void 0, function* () {
        it('gets marco details', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            const marcoDetails = {
                marcoDetails: 'some marco deets',
            };
            serviceClientStub
                .request
                .withArgs(`/integrations/${definitionId}/integration/marco`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.resolve({
                status: 200,
                json: () => __awaiter(this, void 0, void 0, function* () { return marcoDetails; }),
            }));
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            const result = yield integration.getMarcoDetails(serviceClientStub);
            expect(result).toEqual(marcoDetails);
        }));
        it('bubbles up error if encountered', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            serviceClientStub
                .request
                .withArgs(`/integrations/${definitionId}/integration/marco`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.reject(new Error('is broken')));
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            yield expect(integration.getMarcoDetails(serviceClientStub))
                .rejects
                .toMatchObject({
                message: 'Error: is broken',
            });
        }));
        it('throws error if non-200 status received', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            serviceClientStub
                .request
                .withArgs('/integrations/carrier-integration-stub/integration/marco', {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.api+json',
                    'Content-Type': 'application/vnd.api+json',
                },
            })
                .onFirstCall()
                .returns(Promise.resolve({
                status: 400,
                json: () => __awaiter(this, void 0, void 0, function* () { return ({ fail: 'broken' }); }),
            }));
            const integration = new Integration_1.Integration(registryStub, logStub, definitionId);
            yield expect(integration.getMarcoDetails(serviceClientStub))
                .rejects
                .toMatchObject({
                message: 'Error retrieving marco: {"fail":"broken"}',
            });
        }));
    }));
});
//# sourceMappingURL=Integration.test.js.map