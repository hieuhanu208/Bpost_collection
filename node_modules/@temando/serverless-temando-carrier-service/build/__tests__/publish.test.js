"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const mockFs = require("mock-fs-require-fix");
const service_client_factory_1 = require("@temando/service-client-factory");
const awsMock = require("aws-sdk-mock");
const sinon = require("sinon");
const nock = require("nock");
const publish_1 = require("./../publish");
const integration = require("./fixture/integration.json");
const stubTsDefinition = require("./fixture/ts-definition.json");
const stubTsEnv = require("./fixture/ts-env.json");
describe('publish tests', () => {
    const logStub = sinon.stub();
    const integrationId = 'test-integration';
    const integrationEndpoint = 'https://abcdefghij.execute-api.eu-west-1.amazonaws.com/dev';
    beforeEach(() => {
        mockFs({
            'ts-definition.json': JSON.stringify(stubTsDefinition),
            'ts-env.json': JSON.stringify(stubTsEnv),
        });
        awsMock.mock('S3', 'getObject', {
            region: 'eu-west-1',
            integrationEndpoint,
        });
    });
    afterEach(() => {
        mockFs.restore();
        awsMock.restore('S3');
    });
    /**
     * @todo come back to this when time permits:
     * Doesn't seem like aws-sdk-mock works with the way we are using the S3 client
     * right now. It expects the bucket name to be passed in on the getObject call,
     * but we pass it in on construction of the S3 client instance.
     *
     * Also the mock-fs stuff isn't working as expected -- doesn't seem to honour
     * lazy requires (which aws-sdk uses, probably other libraries do too) and
     * tries to read from the mocked fs, which obviously doesn't have any files
     * except for the env and definition files as mocked by us.
     */
    describe('publish', () => {
        it.skip('publishes to carrier service', () => __awaiter(this, void 0, void 0, function* () {
            // Mock the marco endpoint
            nock(`${integrationEndpoint}`)
                .get(`/integrations/${integrationId}/integration/marco`)
                .reply(200, {
                test: 'this is some marco stuff',
            });
            // Mock the marco endpoint
            nock(`${integrationEndpoint}`)
                .get(`/integrations/${integrationId}/integration`)
                .reply(200, {
                test: 'this is some integration stuff',
            });
            yield publish_1.publish('eu-west-1', 'test', console.log);
        }));
    });
    describe('sendRequest', () => {
        it('can publish to carrier service', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            const payload = {
                result: 'hooray!',
            };
            serviceClientStub
                .request
                .withArgs('/carriers', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/vnd.api+json',
                    'Accept': 'application/vnd.api+json',
                },
                body: JSON.stringify(integration),
            })
                .onFirstCall()
                .returns(Promise.resolve({
                status: 201,
                json: () => __awaiter(this, void 0, void 0, function* () { return payload; }),
            }));
            const responseBody = yield publish_1.sendRequest(integration, serviceClientStub, logStub);
            expect(responseBody).toEqual(payload);
        }));
        it('throws error if an error occurs', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            const payload = {
                errors: 'broken',
            };
            serviceClientStub
                .request
                .withArgs('/carriers', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/vnd.api+json',
                    'Accept': 'application/vnd.api+json',
                },
                body: JSON.stringify(integration),
            })
                .onFirstCall()
                .returns(Promise.reject({
                status: 400,
                json: () => __awaiter(this, void 0, void 0, function* () { return payload; }),
            }));
            let caughtError;
            try {
                yield publish_1.sendRequest(integration, serviceClientStub, logStub);
            }
            catch (error) {
                caughtError = error;
            }
            expect(caughtError).not.toEqual(undefined);
        }));
        it('throws error if response status is not 201', () => __awaiter(this, void 0, void 0, function* () {
            const serviceClientStub = sinon.createStubInstance(service_client_factory_1.ServiceClient);
            const payload = {
                errors: 'broken',
            };
            serviceClientStub
                .request
                .withArgs('/carriers', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/vnd.api+json',
                    'Accept': 'application/vnd.api+json',
                },
                body: JSON.stringify(integration),
            })
                .onFirstCall()
                .returns(Promise.resolve({
                status: 400,
                json: () => __awaiter(this, void 0, void 0, function* () { return payload; }),
            }));
            const expectedError = new Error(`Error Publishing Integration Details: ${JSON.stringify(payload)}`);
            let caughtError;
            try {
                yield publish_1.sendRequest(integration, serviceClientStub, logStub);
            }
            catch (error) {
                caughtError = error;
            }
            expect(caughtError).toEqual(expectedError);
        }));
    });
});
//# sourceMappingURL=publish.test.js.map