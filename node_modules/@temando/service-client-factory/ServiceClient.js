"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@temando/errors");
const aws_sdk_1 = require("aws-sdk");
const events_1 = require("events");
const aws4 = require("aws4");
const fetch = require("isomorphic-fetch");
const Joi = require("joi");
const lutils_1 = require("lutils");
const url_1 = require("url");
const uuid = require("uuid/v4");
const pkgJson = require("./package.json");
/**
 * Standardises service-to-service communication among Temando Services.
 *
 * Each method for the different supported transport types uses consistent interface between them,
 * and abstracts the configuration knowledge for easier use.
 */
class ServiceClient extends events_1.EventEmitter {
    /**
     * Creates an instance of a Temando Service Client used to communicate via the following methods:
     * - HTTP
     * - Amazon SQS
     * - Amazon SNS
     * - Amazon Kinesis
     *
     * Note: You are required to pass in at least one method configuration in order to use the Service Client
     */
    constructor(config) {
        super();
        this.createClientValidation = Joi.object().keys({
            name: Joi.string().min(1).required(),
            callId: Joi.string().guid({ version: ['uuidv4'] }).required(),
            callDepth: Joi.number().integer().min(0).required(),
            sovereignty: Joi.string().min(2).required(),
            accountId: Joi.string().guid({ version: ['uuidv4'] }).required(),
            code: Joi.string().required(),
            origin: Joi.string().required(),
            endpoint: Joi.string().uri(),
            region: Joi.string(),
            defaultHeaders: Joi.object().pattern(/^.*$/, Joi.alternatives().try(Joi.string().min(1), Joi.number(), Joi.boolean())).optional(),
            queues: Joi.array()
                .items(Joi.object({
                id: Joi.string(),
                url: Joi.string().uri(),
            })),
            topics: Joi.array()
                .items(Joi.object({
                id: Joi.string(),
                arn: Joi.string(),
            })),
            streams: Joi.array()
                .items(Joi.object({
                id: Joi.string(),
                name: Joi.string(),
            })),
            awsSDK: Joi.any().optional(),
        });
        Joi.validate(config, this.createClientValidation, (err) => { if (err) {
            throw new errors_1.ValidationError(err);
        } });
        Object.assign(this, config || {});
        const awsSDK = config.awsSDK || { SQS: aws_sdk_1.SQS, Kinesis: aws_sdk_1.Kinesis, SNS: aws_sdk_1.SNS, config: aws_sdk_1.config };
        this.credentials = awsSDK.config.credentials;
        if (this.queues && this.queues.length > 0) {
            this.sqsClient = new awsSDK.SQS({ region: this.region });
        }
        if (this.topics && this.topics.length > 0) {
            this.snsClient = new awsSDK.SNS({ region: this.region });
        }
        if (this.streams && this.streams.length > 0) {
            this.kinesisClient = new awsSDK.Kinesis({ region: this.region });
        }
    }
    /**
     * Makes a request to a Temando Service using a HTTP Endpoint
     * @param path Path to request from eg. `shipments/<id>/<shipmentId>`
     * @param config `fetch()` configuration object
     */
    request(path, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = uuid();
            const url = url_1.parse(`${this.endpoint}${path}`);
            const headers = this.createHeaders(config);
            const signedHeaders = aws4.sign(Object.assign({}, config, { headers, host: url.hostname, path: url.pathname, region: this.region, service: 'execute-api' }), this.credentials).headers;
            this.emit('request.start', {
                serviceName: this.name,
                eventId,
                endpoint: this.endpoint,
                path,
                config: Object.assign({}, config, { headers }),
            });
            const response = yield fetch(`${this.endpoint}${path}`, Object.assign({}, config, { headers: signedHeaders }));
            this.emit('request.end', {
                serviceName: this.name,
                eventId,
                endpoint: this.endpoint,
                path,
                config: Object.assign({}, config, { headers }),
                response,
            });
            return response;
        });
    }
    /**
     * Enqueues a message in an SQS Queue
     * @param name Queue name - from configuration
     * @param config message request configuration object
     */
    enqueue(name, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = uuid();
            const queue = this.queues.filter((q) => q.id === name)[0];
            const headers = this.createHeaders(config);
            const params = {
                QueueUrl: queue.url,
                MessageAttributes: this.getMsgAttrFromHeaders(headers) || undefined,
                MessageBody: config.body,
            };
            this.emit('enqueue.start', {
                serviceName: this.name,
                eventId,
                name: queue.id,
                queueUrl: queue.url,
                config: Object.assign({}, config, { headers }),
            });
            const response = yield this.sqsClient.sendMessage(params).promise();
            this.emit('enqueue.end', {
                serviceName: this.name,
                eventId,
                name: queue.id,
                queueUrl: queue.url,
                config: Object.assign({}, config, { headers }),
                response,
            });
            return response;
        });
    }
    /**
     * Sends a message to an SNS Topic
     * @param name Topic name - from configuration
     * @param config message request configuration object
     */
    message(name, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = uuid();
            const topic = this.topics.filter((t) => t.id === name)[0];
            const headers = this.createHeaders(config);
            const params = {
                TopicArn: topic.arn,
                Message: config.body,
                MessageAttributes: this.getMsgAttrFromHeaders(headers) || undefined,
                Subject: config.subject || undefined,
            };
            this.emit('message.start', {
                serviceName: this.name,
                eventId,
                name: topic.id,
                topicArn: topic.arn,
                config: Object.assign({}, config, { headers }),
            });
            const response = yield this.snsClient.publish(params).promise();
            this.emit('message.end', {
                serviceName: this.name,
                eventId,
                name: topic.id,
                topicArn: topic.arn,
                config: Object.assign({}, config, { headers }),
                response,
            });
            return response;
        });
    }
    /**
     * Sends a payload to a Kinesis Stream
     * @param name Stream name - from configuration
     * @param config payload request configuration object
     */
    stream(name, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = uuid();
            const stream = this.streams.filter((s) => s.id === name)[0];
            const headers = this.createHeaders(config);
            const params = {
                StreamName: stream.name,
                Data: JSON.stringify({
                    headers,
                    body: config.body,
                }),
                PartitionKey: config.partitionKey,
                ExplicitHashKey: config.explicitHashKey || undefined,
                SequenceNumberForOrdering: config.sequenceNumber || undefined,
            };
            this.emit('stream.start', {
                serviceName: this.name,
                eventId,
                name: stream.id,
                streamName: stream.name,
                config: Object.assign({}, config, { headers }),
            });
            const response = yield this.kinesisClient.putRecord(params).promise();
            this.emit('stream.end', {
                serviceName: this.name,
                eventId,
                name: stream.id,
                streamName: stream.name,
                config: Object.assign({}, config, { headers }),
                response,
            });
            return response;
        });
    }
    /**
     * Create headers from a combination of mandatory, default and on-request defined headers
     * @param config configuration object
     */
    createHeaders(config) {
        const { name: moduleName, version: moduleVersion } = pkgJson;
        return Object.assign({}, this.defaultHeaders || {}, config.headers || {}, { 'account-id': this.accountId, 'code': this.code, 'sovereignty': this.sovereignty, 'x-temando-service-call': this.callId, 'x-temando-service-call-depth': this.callDepth, 'origin': this.origin, 'user-agent': `${moduleName}@${moduleVersion}` });
    }
    /**
     * Return AWS SQS and SNS compatible MessageAttribute.DataType compatible strings
     *
     * @param value
     */
    getDataType(value) {
        if (lutils_1.isNumber(value)) {
            return 'Number';
        }
        else if (['Buffer', 'Uint8Array', 'Blob'].includes(typeof value)) {
            return 'Binary';
        }
        return 'String';
    }
    /**
     * Generates Amazon SNS and SQS Compatible Message Attributes
     *
     * @param headers Headers object
     */
    getMsgAttrFromHeaders(headers) {
        const attributes = {};
        Object.keys(headers).forEach((key) => {
            const value = headers[key];
            const dataType = this.getDataType(value);
            const dataTypeKey = `${dataType === 'Number' ? 'String' : dataType}Value`;
            attributes[key] = {
                DataType: dataType,
                [dataTypeKey]: dataType === 'Number' ? String(value) : value,
            };
        });
        return attributes;
    }
}
exports.ServiceClient = ServiceClient;
//# sourceMappingURL=ServiceClient.js.map