"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@temando/errors");
const service_registry_lib_1 = require("@temando/service-registry-lib");
const events_1 = require("events");
const Joi = require("joi");
const uuid = require("uuid/v4");
const DependencyError_1 = require("./errors/DependencyError");
const ServiceClient_1 = require("./ServiceClient");
const utils_1 = require("./utils");
function getDeploymentForRegion(deployment) {
    return deployment.region === this.region;
}
/**
 * Creates Service Clients for Temando Service inter-communication based on `ts-definition` configuration
 * and `ts-env` environment variables
 *
 */
class ServiceClientFactory extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.callIdValidation = Joi.string().guid({ version: ['uuidv4'] });
        this.constructorValidation = Joi.object().keys({
            accountId: Joi.string().guid({ version: ['uuidv4'] }),
            code: Joi.string(),
            sovereignty: Joi.string(),
            callId: this.callIdValidation,
            callDepth: Joi.number().integer().min(0),
            tsDefinition: Joi.object().required(),
            tsEnv: Joi.object().required(),
        }).optionalKeys('code', 'sovereignty', 'accountId');
        const sv = new service_registry_lib_1.Schemas();
        // Validate configuration
        Joi.validate(config, this.constructorValidation, (err) => { if (err) {
            throw new errors_1.ValidationError(err);
        } });
        // Default to newly generated uuid() if one doesn't exist
        this.callId = config.callId || uuid();
        Object.assign(this, config);
        try {
            sv.validate(Object.assign({ $schema: 'http://service-registry.temando.com/schema/service-definition+v1#' }, this.tsDefinition));
        }
        catch (e) {
            throw new errors_1.ValidationError(e);
        }
        try {
            sv.validate(Object.assign({ $schema: 'http://service-registry.temando.com/schema/service-env+v1#' }, this.tsEnv));
        }
        catch (e) {
            throw new errors_1.ValidationError(e);
        }
        this.registeredServices = this.tsEnv.services.filter((service) => this.tsDefinition.dependencies.includes(service.id)).reduce((accumulator, currentService) => {
            accumulator[currentService.id] = currentService;
            return accumulator;
        }, {});
        // Check for unregistered services that are dependencies
        const unregisteredDependencies = this.tsDefinition.dependencies.filter((dependency) => !this.isRegisteredService(dependency));
        if (unregisteredDependencies.length > 0) {
            throw new DependencyError_1.DependencyError('Unable to register the following dependencies:' +
                ` ${JSON.stringify(unregisteredDependencies)} - no configuration found`);
        }
    }
    registerService({ serviceName, currentRegion, deployments }) {
        if (this.isRegisteredService(serviceName)) {
            throw new errors_1.ValidationError(`Service ${serviceName} already registered`);
        }
        const sv = new service_registry_lib_1.Schemas();
        for (const deployment of deployments) {
            sv.validate(Object.assign({ $schema: 'http://service-registry.temando.com/schema/service-deployment+v1#' }, deployment));
        }
        this.registeredServices[serviceName] = { id: serviceName, currentRegion, deployments };
    }
    /**
     * Checks if registered service exists
     */
    isRegisteredService(serviceName) {
        return !!this.registeredServices[serviceName];
    }
    create({ name, config = {} }) {
        if (!this.registeredServices[name]) {
            throw new DependencyError_1.DependencyError(`Could not find registered service '${name}'`);
        }
        const sovereignty = this.sovereignty || config.sovereignty;
        const deployment = this.getServiceDeployments(name, sovereignty);
        const serviceClient = new ServiceClient_1.ServiceClient(Object.assign({ name, callId: this._callId, sovereignty, origin: this.tsDefinition.id, callDepth: this.callDepth, endpoint: deployment.endpoint || undefined, queues: deployment.queues || undefined, topics: deployment.topics || undefined, streams: deployment.streams || undefined, region: deployment.region, accountId: this.accountId || undefined, code: this.code || undefined }, config));
        this.emit('create', serviceClient);
        return serviceClient;
    }
    set callId(callId) {
        Joi.validate(callId, this.callIdValidation, (err) => { if (err) {
            throw new errors_1.ValidationError(err);
        } });
        this._callId = callId;
    }
    get callId() {
        return this._callId;
    }
    /**
     * Gets definition for a specific service and sovereignty
     * @param name Name of service to get definition for
     * @param sovereignty Sovereignty to get service definition for
     */
    getServiceDeployments(name, sovereignty) {
        const serviceDefinition = this.registeredServices[name];
        if (!utils_1.SovereigntyMap[sovereignty]) {
            throw new DependencyError_1.DependencyError(`Could not instantiate service client for registered service '${name}' - ` +
                `Invalid sovereignty '${sovereignty}'.`);
        }
        const availableRegions = utils_1.SovereigntyMap[sovereignty].AwsRegions;
        if (availableRegions.length === 0) {
            throw new DependencyError_1.DependencyError(`Could not instantiate service client for registered service '${name}' - ` +
                `No configured regions available for sovereignty '${sovereignty}'.`);
        }
        // If current region is available, return that
        if (availableRegions.indexOf(serviceDefinition.currentRegion) !== -1) {
            const deployment = serviceDefinition.deployments.find(getDeploymentForRegion.bind({ region: serviceDefinition.currentRegion }));
            if (!deployment) {
                throw new DependencyError_1.DependencyError(`Could not instantiate service client for registered service '${name}' - ` +
                    `No region specified, and no current region defined in environment variables.`);
            }
            return deployment;
        }
        // Pick random region deployment in sovereignty if current region doesn't have one
        return serviceDefinition.deployments[Math.floor(Math.random() * serviceDefinition.deployments.length)];
    }
}
exports.ServiceClientFactory = ServiceClientFactory;
//# sourceMappingURL=ServiceClientFactory.js.map