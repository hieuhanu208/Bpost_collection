import { IEventSignatures } from '../types/EventSignatures';
export declare function parseStack(stack: any, at?: number): any;
export declare type IDebug = boolean;
export declare class Mediator {
    /** Whether to emit debug messages when middlewares are being loaded based on event dependencies */
    DEBUG: IDebug;
    private events;
    private declarations;
    constructor(config?: {
        DEBUG?: Mediator['DEBUG'];
    });
    /**
     * Emit an event, asynchronously.
     */
    emit: (key: string, ...payload: any[]) => Promise<any>;
    /**
     * Add a listener to an event
     *
     * @example
     *
     * // In this example; the number describes the order in which events are executed
     *
     * mediator.on('foo::after', () => 4) // last
     * mediator.on('foo::before', () => 2)
     * mediator.on('foo::before', () => 1) // first
     * mediator.on('foo', () => 3)
     * mediator.on('foo::after', () => 5)
     *
     * mediator.emit('foo')
     */
    on: IEventSignatures;
    /** Add listener to an event, but only fire the callback once */
    once: IEventSignatures;
    /** Remove a listener which matches `callback` */
    off(key: string, callback: any): boolean;
    /**
     * Declare an event will be avaliable
     */
    declare(key: string, config?: {}): void;
    /**
     * Checks that all listened for events are also declared
     */
    validate: ({log}?: {
        log?: boolean;
    }) => boolean;
    /** Emits a debug message formatted in a standard way */
    debug({message, type, key, stack, stackPosition, debug}: any): void;
}
