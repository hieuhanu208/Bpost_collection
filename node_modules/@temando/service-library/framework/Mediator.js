"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const c = require("chalk");
const Event_1 = require("./Event");
function parseStack(stack, at = 2) {
    const calleeLine = stack.split('\n')[at];
    return calleeLine;
}
exports.parseStack = parseStack;
class Mediator {
    constructor(config = {}) {
        this.events = {};
        this.declarations = {};
        /**
         * Emit an event, asynchronously.
         */
        this.emit = (key, ...payload) => {
            const event = this.events[key];
            if (!event) {
                this.debug({
                    type: 'UNUSED',
                    key,
                    message: 'Event was emitted to no listeners',
                });
                return Promise.resolve();
            }
            return event.propagate(...payload).catch((error) => __awaiter(this, void 0, void 0, function* () {
                yield this.emit('error', error);
                throw error;
            }));
        };
        /**
         * Add a listener to an event
         *
         * @example
         *
         * // In this example; the number describes the order in which events are executed
         *
         * mediator.on('foo::after', () => 4) // last
         * mediator.on('foo::before', () => 2)
         * mediator.on('foo::before', () => 1) // first
         * mediator.on('foo', () => 3)
         * mediator.on('foo::after', () => 5)
         *
         * mediator.emit('foo')
         */
        this.on = (key, callback, options) => {
            // Creating a stack is expensive, do it only if instructed.
            const stack = (this.DEBUG) ? new Error(key).stack : undefined;
            const [cleanKey, psuedo] = key.split('::');
            key = cleanKey;
            const event = this.events[key] || new Event_1.Event(key);
            /**
             * Psuedo keys determine calling order.
             */
            if (psuedo === 'before') {
                event.addBefore({ callback, stack }, options);
            }
            else if (psuedo === 'after') {
                event.addAfter({ callback, stack }, options);
            }
            else {
                event.add({ callback, stack }, options);
            }
            this.events[key] = event;
            return event;
        };
        /** Add listener to an event, but only fire the callback once */
        this.once = (key, callback, options = {}) => {
            this.on(key, callback, Object.assign({}, options, { limit: 1 }));
        };
        /**
         * Checks that all listened for events are also declared
         */
        this.validate = ({ log } = {}) => {
            let valid = true;
            Object.keys(this.events).forEach((key) => {
                for (const { stack } of this.events[key].ordered) {
                    if (!this.declarations[key]) {
                        valid = false;
                        this.debug({
                            key,
                            type: 'UNDECLARED',
                            message: 'Event has not been declared',
                            stackPosition: 2,
                            debug: log,
                            stack,
                        });
                    }
                }
            });
            // tslint:disable-next-line:no-floating-promises
            this.emit('validated', valid);
            return valid;
        };
        Object.assign(this, config);
        this.declare('error');
        this.declare('validated');
    }
    /** Remove a listener which matches `callback` */
    off(key, callback) {
        const event = this.events[key];
        if (!event) {
            return false;
        }
        const listener = event.get(callback);
        if (!listener) {
            return false;
        }
        event.remove(listener);
        return true;
    }
    /**
     * Declare an event will be avaliable
     */
    declare(key, config = {}) {
        // TODO: add config with schema validation.
        // - Joi ?
        this.declarations[key] = config;
    }
    /** Emits a debug message formatted in a standard way */
    debug({ message, type, key, stack = new Error().stack, stackPosition = 3, debug, }) {
        debug = debug || this.DEBUG;
        if (!debug) {
            return;
        }
        const name = this.constructor.name.toUpperCase();
        console.warn(`[${c.grey(name)} ${c.white(type)}] "${c.bold(key)}" ${message}`);
        if (stack) {
            console.warn(parseStack(stack, stackPosition));
        }
    }
}
exports.Mediator = Mediator;
//# sourceMappingURL=Mediator.js.map