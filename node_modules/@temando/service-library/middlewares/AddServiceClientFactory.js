"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const service_client_factory_1 = require("@temando/service-client-factory");
/**
 * This function exports Service Library compatible middleware for
 * instantiating Service Client Factory
 *
 * @param config  Service Client Factory configuration
 */
function AddServiceClientFactory(config) {
    return (m) => {
        m.declare('serviceClientFactory.ready');
        const addScfListener = (event) => {
            const { request: { headers }, } = event;
            const accountId = config.accountId || event.accountId || headers['account-id'];
            const sovereignty = config.sovereignty || event.sovereignty || headers.sovereignty;
            const code = config.code || event.code || headers.code;
            const callId = event.callId;
            const callDepth = config.callDepth || parseInt(headers['x-temando-service-call-depth'], 10) || 0;
            // This is the depth for any call originating from this service.
            const newCallDepth = callDepth + 1;
            event.serviceClientFactory = new service_client_factory_1.ServiceClientFactory(Object.assign({ accountId,
                sovereignty,
                code,
                callId, callDepth: newCallDepth }, config));
            event.serviceClientFactory.on('create', (serviceClient) => {
                const timers = new Map();
                serviceClient.on('request.start', (req) => {
                    if (!event.instrumentation) {
                        return;
                    }
                    timers.set(req.eventId, event.instrumentation.timer());
                    event.instrumentation.info(`[ServiceClient][${req.serviceName}][START] Http Request to ${req.endpoint}${req.path}`, {
                        config: req.config,
                    });
                    // Just in case, shouldn't occur though..
                    if (!req.config) {
                        return;
                    }
                    event.instrumentation.count({
                        name: 'http.request',
                        tags: {
                            callDepth: newCallDepth,
                            method: req.config.method,
                            target: serviceClient.name,
                        },
                    });
                });
                serviceClient.on('request.end', (res) => __awaiter(this, void 0, void 0, function* () {
                    if (!event.instrumentation) {
                        return;
                    }
                    const responseClone = res.response.clone();
                    event.instrumentation.info(`[ServiceClient][${res.serviceName}][END] Http Request to ${res.endpoint}${res.path}`, {
                        config: res.config,
                        response: {
                            status: responseClone.status,
                            statusText: responseClone.statusText,
                            headers: responseClone.headers._headers,
                            body: yield responseClone.text(),
                        },
                    });
                    // Just in case, shouldn't occur though..
                    if (!res.config) {
                        return;
                    }
                    event.instrumentation.count({
                        name: 'http.response',
                        tags: {
                            httpCode: responseClone.status,
                            method: res.config.method,
                            source: serviceClient.name,
                        },
                    });
                    if (timers.has(res.eventId)) {
                        event.instrumentation.timing({
                            name: 'http.timing',
                            value: timers.get(res.eventId),
                            tags: {
                                callDepth: newCallDepth,
                                httpCode: responseClone.statusCode,
                                method: res.config.method,
                                source: serviceClient.name,
                            },
                        });
                        timers.delete(res.eventId);
                    }
                    if (responseClone.status && responseClone.status >= 500) {
                        event.instrumentation.count({
                            name: 'http.request.error',
                            tags: {
                                callDepth: newCallDepth,
                                method: res.config.method,
                                target: serviceClient.name,
                            },
                        });
                    }
                }));
                serviceClient.on('enqueue.start', (req) => {
                    if (!event.instrumentation) {
                        return;
                    }
                    event.instrumentation.info(`[ServiceClient][${req.serviceName}][START] Enqueue Request to ${req.name} (${req.queueUrl}) [ID: ${req.eventId}]`, {
                        config: req.config,
                    });
                });
                serviceClient.on('enqueue.end', (res) => {
                    if (!event.instrumentation) {
                        return;
                    }
                    event.instrumentation.info(`[ServiceClient][${res.serviceName}][END] Enqueue Request to ${res.name} (${res.queueUrl}) [ID: ${res.eventId}]`, {
                        config: res.config,
                        response: res.response,
                    });
                });
                serviceClient.on('stream.start', (req) => {
                    if (!event.instrumentation) {
                        return;
                    }
                    event.instrumentation.info(`[ServiceClient][${req.serviceName}][START] Stream Request to ${req.name} (${req.streamName}) [ID: ${req.eventId}]`, {
                        config: req.config,
                    });
                });
                serviceClient.on('stream.end', (res) => {
                    if (!event.instrumentation) {
                        return;
                    }
                    event.instrumentation.info(`[ServiceClient][${res.serviceName}][END] Stream Request to ${res.name} (${res.streamName}) [ID: ${res.eventId}]`, {
                        config: res.config,
                        response: res.response,
                    });
                });
                serviceClient.on('message.start', (req) => {
                    if (!event.instrumentation) {
                        return;
                    }
                    event.instrumentation.info(`[ServiceClient][${req.serviceName}][START] Message Request to ${req.name} (${req.topicArn}) [ID: ${req.eventId}]`, {
                        config: req.config,
                    });
                });
                serviceClient.on('message.end', (res) => {
                    if (!event.instrumentation) {
                        return;
                    }
                    event.instrumentation.info(`[ServiceClient][${res.serviceName}][END] Message Request to ${res.name} (${res.topicArn}) [ID: ${res.eventId}]`, {
                        config: res.config,
                        response: res.response,
                    });
                });
            });
            return m.emit('serviceClientFactory.ready', event);
        };
        m.on('http.request::before', addScfListener);
        m.on('kinesis.event::before', addScfListener);
    };
}
exports.AddServiceClientFactory = AddServiceClientFactory;
//# sourceMappingURL=AddServiceClientFactory.js.map