"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const instrument_1 = require("@temando/instrument");
/**
 * Instrumentation middleware
 *
 * Integrates with:
 * - `Http` middleware
 * - `AddServiceClientFactory` middleware
 * - Any handler
 */
function Instrumentation({ tsDefinition }) {
    return (m) => {
        const timers = new Map();
        m.declare('instrumentation');
        m.declare('instrumentation.end');
        const addInstrumentationListener = (event) => {
            event.instrumentation = new instrument_1.InstrumentClient({
                consumerServiceName: tsDefinition.id,
            });
            return m.emit('instrumentation.ready', event);
        };
        m.on('event', addInstrumentationListener);
        m.on('kinesis.event', addInstrumentationListener);
        m.on('http.request', ({ id, request, instrumentation }) => {
            timers.set(id, instrumentation.timer());
            instrumentation.count({
                name: 'service.http.request',
                tags: {
                    callDepth: request.headers['x-temando-service-call-depth'],
                    method: request.method,
                    source: request.headers.origin,
                },
            });
            instrumentation.log('info', 'request', { request: Object.assign({}, request) });
        });
        m.on('http.exception', ({ request, response, instrumentation }) => {
            instrumentation.count({
                name: 'service.http.request.error',
                tags: {
                    callDepth: request.headers['x-temando-service-call-depth'],
                    method: request.method,
                    source: request.headers.origin,
                },
            });
            instrumentation.log('info', 'response', { response: Object.assign({}, response) });
        });
        m.on('http.response', ({ id, request, response, instrumentation }) => {
            if (timers.has(id)) {
                instrumentation.timing({
                    name: 'service.http.timing',
                    value: timers.get(id),
                    tags: {
                        callDepth: request.headers['x-temando-service-call-depth'],
                        httpCode: response.statusCode,
                        method: request.method,
                        source: request.headers.origin,
                    },
                });
                timers.delete(id);
            }
            instrumentation.count({
                name: 'service.http.response',
                tags: {
                    httpCode: response.statusCode,
                    method: request.method,
                    target: request.headers.origin,
                },
            });
            instrumentation.log('info', 'response', { response: Object.assign({}, response) });
        });
        m.on('event.end', (event) => __awaiter(this, void 0, void 0, function* () {
            const { instrumentation } = event;
            if (!instrumentation) {
                return;
            }
            yield m.emit('instrumentation.end', event);
        }));
    };
}
exports.Instrumentation = Instrumentation;
//# sourceMappingURL=Instrumentation.js.map