"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const Http_1 = require("./Http");
function kinesisRecordToRequest(record) {
    const data = JSON.parse(Buffer.from(record.kinesis.data, 'base64').toString('utf8'));
    const { body, headers = {} } = data;
    return { headers, body };
}
/**
 * Kinesis middleware
 *
 * Integrates with:
 * - (required) `LambdaBatch` handler
 */
function Kinesis() {
    return (m) => {
        m.declare('kinesis.event');
        m.declare('kinesis.events.resolved');
        m.on('batch.event.prepare', (mainEvent, { record, handler }) => __awaiter(this, void 0, void 0, function* () {
            const request = kinesisRecordToRequest(record);
            const event = Object.assign({}, mainEvent, { event: mainEvent, request, record: record });
            // Will await both prepare and `http.request`
            Http_1.prepareHttpRequest({ event });
            yield m.emit('kinesis.event', event);
            yield m.emit('handler.request', event);
            const result = yield handler(event);
            record.result = result;
        }));
        m.on('batch.events.resolved', (event) => __awaiter(this, void 0, void 0, function* () {
            const hasErrors = event.records.filter(({ error }) => error);
            if (hasErrors.length) {
                event.error = new errors_1.KinesisProcessError(`Failure to complete ${hasErrors.length} records of ${event.records.length}`);
            }
            event.response = null;
            return m.emit('kinesis.events.resolved', event);
        }));
    };
}
exports.Kinesis = Kinesis;
//# sourceMappingURL=Kinesis.js.map