"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const generic_schema_1 = require("@temando/generic-schema");
const Ajv = require("ajv");
const lutils_1 = require("lutils");
const errors_1 = require("../../errors");
const filter_fields_config_schema_v1_1 = require("../../schema/filter-fields-config-schema+v1");
const SchemaValidator_1 = require("../../schema/SchemaValidator");
const operatorMap_1 = require("./operatorMap");
const schema = new Ajv();
schema.addSchema(filter_fields_config_schema_v1_1.default);
schema.addSchema(generic_schema_1.schemas.filter);
function translateSearchOperator(operator) {
    if (!operatorMap_1.default[operator]) {
        throw new errors_1.ValidationError({
            title: 'Invalid Filter',
            detail: `The filter operator '${operator}' is not a valid filter`,
        });
    }
    return operatorMap_1.default[operator];
}
function validateFilter(filter, filterFieldConfig) {
    if (filterFieldConfig) {
        filter.forEach((f) => {
            if (f.path && typeof f.path === 'string' && f.operator && typeof f.operator === 'string') {
                if (!filterFieldConfig[f.path]) {
                    throw new errors_1.ValidationError({
                        title: 'Invalid Filter',
                        detail: `The filter path '${f.path}' is not filterable`,
                        meta: {
                            supportedPaths: Object.keys(filterFieldConfig),
                        },
                    });
                }
                if (!filterFieldConfig[f.path].supportedOperators.includes(f.operator)) {
                    throw new errors_1.ValidationError({
                        title: 'Invalid Filter',
                        // tslint:disable-next-line:max-line-length
                        detail: `The filter operator '${f.operator}' is not a supported operator for the path '${f.path}'`,
                        meta: {
                            supportedOperators: filterFieldConfig[f.path].supportedOperators,
                        },
                    });
                }
            }
        });
    }
    const validate = SchemaValidator_1.SchemaValidator(schema);
    validate(generic_schema_1.schemas.filter.id, filter);
}
// FIXME: provide a description
function SearchFilter({ filterFieldsConfig, callback } = {}) {
    const hasFilterFieldsConfig = typeof filterFieldsConfig === 'object';
    let filterableFields = [];
    if (hasFilterFieldsConfig) {
        const validate = SchemaValidator_1.SchemaValidator(schema);
        validate('https://schemas.temando.com/filter-fields-config-schema+v1.json', filterFieldsConfig);
        filterableFields = Object.keys(filterFieldsConfig);
    }
    return (m) => {
        m.on('http.request', (event) => {
            const { filter } = event.request.query;
            if (filter) {
                let parsedFilter;
                try {
                    parsedFilter = JSON.parse(filter);
                }
                catch (e) {
                    // ignore
                }
                const searchAttributes = {};
                if (parsedFilter) {
                    // Validate filter against schema
                    validateFilter(parsedFilter, filterFieldsConfig);
                    parsedFilter.forEach((searchOperator) => {
                        if (hasFilterFieldsConfig) {
                            const { path } = searchOperator;
                            const filterFieldConfig = filterFieldsConfig[path];
                            searchOperator.path = filterFieldConfig.mappedPath;
                            if (typeof callback === 'function') {
                                searchOperator = callback(filterFieldConfig, path, searchOperator);
                            }
                        }
                        lutils_1.merge(searchAttributes, {
                            [searchOperator.path]: {
                                [translateSearchOperator(searchOperator.operator)]: searchOperator.value,
                            },
                        });
                    });
                }
                // Attach searchAttributes to event.request.searchFilter
                event.searchFilter = searchAttributes;
            }
        });
    };
}
exports.SearchFilter = SearchFilter;
//# sourceMappingURL=SearchFilter.js.map