/// <reference types="node" />
import * as EventEmitter from 'events';
import * as Joi from 'joi';
import { ICountArgs, IGaugeArgs, IHistogramArgs, ILogArgs, ILogData, IMetricArgs, IMetricData, ITags, ITimer, ITimingArgs } from './types';
/**
 * The Client.
 */
export declare class InstrumentClient extends EventEmitter {
    consumerServiceName: string;
    test: boolean;
    events: EventEmitter;
    plugins: any[];
    metricsData: IMetricData[];
    logsData: ILogData[];
    tags: ITags;
    metricNameSchema: Joi.StringSchema;
    accountSchema: Joi.StringSchema;
    codeSchema: Joi.StringSchema;
    logSchema: Joi.ObjectSchema;
    metricSchema: Joi.ObjectSchema;
    histogramSchema: Joi.ObjectSchema;
    gaugeSchema: Joi.ObjectSchema;
    countSchema: Joi.ObjectSchema;
    tagSchema: Joi.ArraySchema;
    /**
     * Create a new client.
     *
     * @param {Object} config
     */
    constructor({consumerServiceName}: {
        consumerServiceName: InstrumentClient['consumerServiceName'];
    });
    /**
     * Add a global tag which will be attached to all future messages.
     */
    tag(key: string, value: string): this;
    /**
     * Log a message.
     */
    log(level: ILogArgs['level'], message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    log(args: ILogArgs): any;
    /**
     * Log an emergency message.
     */
    emergency(message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    emergency(args: ILogArgs): any;
    /**
     * Log an alert message.
     */
    alert(message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    alert(args: ILogArgs): any;
    /**
     * Log a critical message.
     */
    critical(message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    critical(args: ILogArgs): any;
    /**
     * Log an error message.
     */
    error(message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    error(args: ILogArgs): any;
    /**
     * Log a warning message.
     *
     * @param {String} message
     * @param {Object} context
     * @return {InstrumentClient}
     */
    warning(message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    warning(args: ILogArgs): any;
    /**
     * Log a notice message.
     */
    notice(message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    notice(args: ILogArgs): any;
    /**
     * Log an info message.
     */
    info(message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    info(args: ILogArgs): any;
    /**
     * Log a debug message.
     */
    debug(message: ILogArgs['message'], context?: ILogArgs['context'], tags?: ILogArgs['tags']): any;
    debug(args: ILogArgs): any;
    /**
     * Add a new metric to collection.
     */
    metric(type: IMetricArgs['type'], name: IMetricArgs['name'], value: IMetricArgs['value'], context?: IMetricArgs['context'], tags?: IMetricArgs['tags']): any;
    metric(args: IMetricArgs): any;
    /**
     * Add count metric to collection.
     */
    count(name: ICountArgs['name'], value?: ICountArgs['value'], context?: ICountArgs['context']): any;
    count(args: ICountArgs): any;
    /**
     * Add gauge metric to collection.
     */
    gauge(name: IGaugeArgs['name'], value: IGaugeArgs['value'], context?: IGaugeArgs['context'], tags?: IGaugeArgs['tags']): any;
    gauge(args: IGaugeArgs): any;
    /**
     * Add histogram metric to collection.
     */
    histogram(name: IHistogramArgs['name'], value: IHistogramArgs['value'], context?: IHistogramArgs['context'], tags?: IHistogramArgs['tags']): any;
    histogram(aHgs: IHistogramArgs): any;
    /**
     * Add timing metric to collection.
     */
    timing(name: ITimingArgs['name'], value: ITimingArgs['value'] | ITimer, context?: ITimingArgs['context'], tags?: ITimingArgs['tags']): any;
    timing(args: ITimingArgs): any;
    /**
     * Creates a timer.
     *
     * Give it to timing() when it's time to commit.
     */
    timer(): ITimer;
}
