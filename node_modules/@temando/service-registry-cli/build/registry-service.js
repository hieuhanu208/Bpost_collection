#!/usr/bin/env node
'use strict';

var _commander = require('commander');

var _commander2 = _interopRequireDefault(_commander);

var _prompt = require('prompt');

var _prompt2 = _interopRequireDefault(_prompt);

var _serviceRegistryLib = require('@temando/service-registry-lib');

var _getAWSCredentials = require('./lib/getAWSCredentials');

var _getAWSCredentials2 = _interopRequireDefault(_getAWSCredentials);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/* eslint max-len: ['error', {'code': 200}] */


_commander2.default.option('-e, --env <env>', 'the environment the registry is', 'dev').option('-m, --mode <mode>', 'set the mode, s3 or local', 's3').option('--profile <profile>', 'AWS profile to use when communicating with Amazon S3');

_commander2.default.command('create').description('initialise a service in the current dir').action(() => {
  const opts = {};
  if (_commander2.default.profile) {
    opts.credentials = (0, _getAWSCredentials2.default)(_commander2.default.profile);
  }
  const r = new _serviceRegistryLib.Registry(_commander2.default.env, _commander2.default.mode, opts);
  const sm = r.sm();

  if (sm.isLocalDefinitionExist() === true) {
    const entry = sm.loadLocalDefinition();
    console.log(`Service "${entry.id}" has already been created!`);
    process.exit(1);
  }

  console.log('Creating a local service definition…');

  _prompt2.default.delimiter = '';
  _prompt2.default.start({
    message: 'Creating a local service definition…\n'
  });

  _prompt2.default.get({
    properties: {
      id: {
        description: 'Service Id?',
        pattern: /^[a-z0-9-]+$/,
        message: 'The service id must be only lowercase letters, numbers, or dashes',
        required: true
      },
      keys: {
        description: 'K/V Key?',
        pattern: /^[a-z0-9-\\/.]+$/,
        type: 'array',
        message: 'The k/v key must be only lowercase letters, numbers, dashes, backslashes or periods',
        required: false
      },
      dependencies: {
        description: 'Dependency Id?',
        pattern: /^[a-z0-9-]+$/,
        type: 'array',
        message: 'The dependency id must be only lowercase letters, numbers, or dashes',
        required: false
      }
    }
  }, (err, result) => {
    if (err) {
      console.log(err.message);
      process.exit(1);
    }

    const kvs = Array.isArray(result.keys) ? result.keys.map(k => {
      return { key: k };
    }) : [];

    const dependencies = Array.isArray(result.dependencies) ? result.dependencies : [];

    const definition = {
      id: result.id,
      kvs: kvs,
      dependencies: dependencies
    };

    try {
      console.log('Writing ./ts-definition.json…');
      sm.writeLocalDefinition(definition);
      console.log('Done.');
      process.exit(0);
    } catch (e) {
      console.log(e.message);
      process.exit(1);
    }
  });
});

_commander2.default.command('register').description('pushes the current service into the registry as a catalog entry').action(_asyncToGenerator(function* () {
  const opts = {};
  if (_commander2.default.profile) {
    opts.credentials = (0, _getAWSCredentials2.default)(_commander2.default.profile);
  }
  const r = new _serviceRegistryLib.Registry(_commander2.default.env, _commander2.default.mode, opts);
  const definition = r.sm().loadLocalDefinition();

  console.log(`Registering "${definition.id}" into "${_commander2.default.env}"…`);

  const catalog = r.catalog();
  catalog.get(definition.id).then(function (entry) {
    const catalogEntry = entry;
    catalogEntry.definition = definition;

    console.log(`Entry for "${definition.id}" exists, updating…`);
    catalog.put(catalogEntry).then(function () {
      console.log('Done.');
    }, function (error) {
      console.warn(error);
      process.exit(1);
    });
  }, function (e) {
    if (e.statusCode !== 404) {
      console.warn(e);
      process.exit(1);
    }

    console.log(`Creating initial entry for "${definition.id}"…`);
    catalog.put({ definition: definition, deployments: [] }).then(function () {
      console.log('Done.');
    }, function (error) {
      console.warn(error);
      process.exit(1);
    });
  });
}));

_commander2.default.command('pull-env <region>').description('Reads a local service definition, then pulls environment information from the registry').action((() => {
  var _ref2 = _asyncToGenerator(function* (region) {
    const opts = {};
    if (_commander2.default.profile) {
      opts.credentials = (0, _getAWSCredentials2.default)(_commander2.default.profile);
    }
    const r = new _serviceRegistryLib.Registry(_commander2.default.env, _commander2.default.mode, opts);
    const catalog = r.catalog();
    const kvStorage = r.kv();
    console.log(`Attempting to pull env info for "${_commander2.default.env}" and deployment region "${region}"…`);

    const definition = r.sm().loadLocalDefinition();
    console.log(`Service "${definition.id}":`);

    const env = { targetService: definition.id, keyValues: [], services: [] };

    console.log(' services:');
    const entries = yield Promise.all(definition.dependencies.map((() => {
      var _ref3 = _asyncToGenerator(function* (d) {
        console.log(`  ${d}`);
        let dependency;

        try {
          dependency = yield catalog.get(d);
        } catch (error) {
          console.warn(`Unable to find service catalog entry for "${d}"!`);
          console.warn(error);
          process.exit(1);
        }

        return dependency;
      });

      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    })()));

    env.services = entries.map(function (entry) {
      const matchingDeployments = entry.deployments.filter(function (deployment) {
        return deployment.region && deployment.region === region;
      });

      if (matchingDeployments.length === 0) {
        console.error(`The entry "${entry.definition.id}" is not deployed in "${region}"`);
        process.exit(1);
      }

      return {
        id: entry.definition.id,
        currentRegion: region,
        deployments: entry.deployments
      };
    });

    console.log(' kvs:');
    env.keyValues = yield Promise.all(definition.kvs.map((() => {
      var _ref4 = _asyncToGenerator(function* (kv) {
        let pair;
        let keyValueObject;

        if (typeof kv === 'string') {
          pair = { key: kv };
        } else {
          pair = kv;
        }

        console.log(`  ${pair.key}`);

        try {
          const value = yield kvStorage.get(pair.key);
          keyValueObject = { key: pair.key, value: value };
        } catch (error) {
          if (!error.hasOwnProperty('code') || error.code !== 'NoSuchKey') {
            console.error(error);
            process.exit(1);
          }

          if (pair.hasOwnProperty('default')) {
            keyValueObject = { key: pair.key, value: pair.default };
          } else {
            console.error(error);
            console.warn(`Missing kv "${pair.key}"!`);
            process.exit(1);
          }
        }

        return keyValueObject;
      });

      return function (_x3) {
        return _ref4.apply(this, arguments);
      };
    })()));

    console.log('Writing ./ts-env.json…');

    try {
      r.sm().writeLocalEnv(env);
    } catch (e) {
      console.error(e);
      process.exit(1);
    }

    console.log('Done.');
  });

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
})());

_commander2.default.parse(process.argv);

if (!process.argv.slice(2).length) {
  _commander2.default.outputHelp();
}