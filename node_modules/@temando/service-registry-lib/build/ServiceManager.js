'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _Schemas = require('./Schemas');

var _Schemas2 = _interopRequireDefault(_Schemas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ServiceManager = function () {
  /**
   * Constructor
   */
  function ServiceManager() {
    _classCallCheck(this, ServiceManager);

    this.schemas = new _Schemas2.default();
    this.definitionFilename = 'ts-definition.json';
    this.envFilename = 'ts-env.json';
    this.fileExtensions = ['yml', 'json'];
  }

  /**
   * Load the local definition from the current working directory
   *
   * @return {Object}
   */


  _createClass(ServiceManager, [{
    key: 'loadLocalDefinition',
    value: function loadLocalDefinition() {
      var extension = this.getExtensionFromAlternatives(this.definitionFilename);
      var path = `${process.cwd()}/${this.definitionFilename.replace(_path2.default.extname(this.definitionFilename), `.${extension}`)}`;

      return this.loadDefinitionFile(path);
    }

    /**
     * Attempt to load a definition file from the given `path`
     *
     * @throws {Error} If service definition is invalid or could not be opened
     * @param  {String} path
     * @return {Object}
     */

  }, {
    key: 'loadDefinitionFile',
    value: function loadDefinitionFile(path) {
      var definition = void 0;

      try {
        definition = _jsYaml2.default.safeLoad(_fs2.default.readFileSync(path));
      } catch (e) {
        throw new Error(`Could not open service definition file at "${path}"`);
      }

      try {
        this.validateDefinition(definition);
      } catch (e) {
        throw new Error(`The service definition at "${path}" is invalid! See: ${e}`);
      }

      return definition;
    }

    /**
     * Get file extension for ts-definition and ts-env from available file extensions (yaml or json)
     * based on what the user has in their given path.
     *
     * Defaults to 'json' if not found
     */

  }, {
    key: 'getExtensionFromAlternatives',
    value: function getExtensionFromAlternatives(filename) {
      return this.fileExtensions.find(function (ext) {
        try {
          _fs2.default.accessSync(`${process.cwd()}/${filename.replace(_path2.default.extname(filename), `.${ext}`)}`, _fs2.default.constants.R_OK);
        } catch (e) {
          return false;
        }
        return true;
      }) || 'json';
    }

    /**
     * Checks if the given `path` exists
     *
     * @param  {String}  path
     * @return {Boolean}
     */

  }, {
    key: 'isDefinitionFileExist',
    value: function isDefinitionFileExist(path) {
      try {
        _fs2.default.accessSync(path, _fs2.default.constants.R_OK);
      } catch (e) {
        return false;
      }
      return true;
    }

    /**
     * Checks if the current working directory contains a local definition file
     *
     * @return {Boolean}
     */

  }, {
    key: 'isLocalDefinitionExist',
    value: function isLocalDefinitionExist() {
      var extension = this.getExtensionFromAlternatives(this.definitionFilename);
      var path = `${process.cwd()}/${this.definitionFilename.replace(_path2.default.extname(this.definitionFilename), `.${extension}`)}`;

      return this.isDefinitionFileExist(path);
    }

    /**
     * Given a `definition` which adheres to `service-definition+v1#`, attempt to
     * write it at the given `path`
     *
     * @throws {Error} If service exists, is invalid or couldn't be written.
     * @param  {String} path
     * @param  {Object} definition
     * @return {Boolean}
     */

  }, {
    key: 'writeDefinitionFile',
    value: function writeDefinitionFile(path, definition) {
      if (this.isDefinitionFileExist(path) === true) {
        throw new Error('Service has already been created.');
      }

      try {
        this.validateDefinition(definition);
      } catch (e) {
        throw new Error(`The service definition at "${path}" is invalid! See: ${e}`);
      }

      if (_path2.default.extname(path) === 'yml') {
        try {
          _fs2.default.writeFileSync(path, _jsYaml2.default.dump(definition, { indent: 2 }), 'utf8');
          return true;
        } catch (e) {
          throw new Error(`Failed to create service ${definition.id} on "${path}". See: ${e}`);
        }
      }

      try {
        _fs2.default.writeFileSync(path, JSON.stringify(definition, null, 2), 'utf8');
        return true;
      } catch (e) {
        throw new Error(`Failed to create service ${definition.id} on "${path}". See: ${e}`);
      }
    }

    /**
     * Writes a given `definition` (`service-definition+v1#`) to a definition file in
     * the current working directory
     *
     * @param  {Object} definition
     * @return {Boolean}
     */

  }, {
    key: 'writeLocalDefinition',
    value: function writeLocalDefinition(definition) {
      var extension = this.getExtensionFromAlternatives(this.definitionFilename);

      var path = `${process.cwd()}/${this.definitionFilename.replace(_path2.default.extname(this.definitionFilename), `.${extension}`)}`;

      return this.writeDefinitionFile(path, definition);
    }

    /**
     * Given a `definition`, attempt to validate it against `service-definition+v1#`
     *
     * @param  {Object} definition
     * @return {Boolean}
     */

  }, {
    key: 'validateDefinition',
    value: function validateDefinition(definition) {
      var definitionData = definition;
      definitionData.$schema = 'http://service-registry.temando.com/schema/service-definition+v1#';
      return this.schemas.validate(definitionData);
    }

    /**
     * Load the local environment file from the current working directory
     *
     * @return {Object}
     */

  }, {
    key: 'loadLocalEnv',
    value: function loadLocalEnv() {
      var extension = this.getExtensionFromAlternatives(this.envFilename);
      var path = `${process.cwd()}/${this.envFilename.replace(_path2.default.extname(this.envFilename), `.${extension}`)}`;

      return this.loadEnvFile(path);
    }

    /**
     * @param path
     * @returns {*}
     */

  }, {
    key: 'loadEnvFile',
    value: function loadEnvFile(path) {
      var env = void 0;

      try {
        env = _jsYaml2.default.safeLoad(_fs2.default.readFileSync(path));
      } catch (e) {
        throw new Error(`Could not open local env file at "${path}"`);
      }

      try {
        this.schemas.validate(env);
      } catch (e) {
        throw new Error(`The env file at "${path}" is invalid! See: ${e}`);
      }

      return env;
    }

    /**
     * Writes a given `env` (service-env+v1#) to an environment file in
     * the current working directory
     *
     * @param  {Object} env
     * @return {Boolean}
     */

  }, {
    key: 'writeLocalEnv',
    value: function writeLocalEnv(env) {
      var envData = env;
      envData.$schema = 'http://service-registry.temando.com/schema/service-env+v1#';
      this.schemas.validate(envData);

      /**
       * NOTE: This is looking for the ts-definition file's extension in order to
       * write a ts-env file with the same file format as it's definition.
       */
      var extension = this.getExtensionFromAlternatives(this.definitionFilename);

      var path = `${process.cwd()}/${this.envFilename.replace(_path2.default.extname(this.envFilename), `.${extension}`)}`;

      if (extension === 'yml') {
        try {
          _fs2.default.writeFileSync(path, _jsYaml2.default.dump(env, { indent: 2 }), 'utf8');
          return true;
        } catch (e) {
          throw new Error(`Failed to write environment file for service ${env.id} on "${path}". See: ${e}`);
        }
      }

      try {
        _fs2.default.writeFileSync(path, JSON.stringify(env, null, 2), 'utf8');
        return true;
      } catch (e) {
        throw new Error(`Failed to write environment file for service ${env.id} on "${path}". See: ${e}`);
      }
    }
  }]);

  return ServiceManager;
}();

exports.default = ServiceManager;
module.exports = exports['default'];