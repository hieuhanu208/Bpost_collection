"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var requireResolve = require("resolve-pkg");
var BabelTransform = (function () {
    function BabelTransform(config, options) {
        if (config === void 0) { config = {}; }
        if (options === void 0) { options = {}; }
        this.config = __assign({ sourceMaps: 'both' }, config);
        this.options = __assign({ servicePath: '', skipOnError: false, logErrors: true, normalizeBabelExt: false }, options);
        // eslint-disable-next-line
        this.babel = require(requireResolve('babel-core', { cwd: this.options.servicePath }));
    }
    BabelTransform.prototype.run = function (_a) {
        var code = _a.code, map = _a.map, relPath = _a.relPath;
        var result = { code: code, map: map, relPath: relPath };
        try {
            var transformed = this.babel.transform(code, __assign({}, this.config, { sourceFileName: relPath, sourceMapTarget: relPath }));
            result = __assign({}, result, transformed, { relPath: this.options.normalizeBabelExt
                    ? relPath.replace(/\.[^.]+$/, '.js')
                    : relPath });
        }
        catch (err) {
            // tslint:disable-next-line:no-console
            if (this.options.logErrors) {
                console.error(err);
            } // eslint-disable-line
            if (!this.options.skipOnError) {
                throw err;
            }
        }
        return result;
    };
    return BabelTransform;
}());
exports.BabelTransform = BabelTransform;
//# sourceMappingURL=Babel.js.map