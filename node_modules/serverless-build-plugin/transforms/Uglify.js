"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var requireResolve = require("resolve-pkg");
var UglifyTransform = (function () {
    function UglifyTransform(config, options) {
        if (config === void 0) { config = {}; }
        if (options === void 0) { options = {}; }
        this.config = __assign({ dead_code: true, unsafe: false }, config);
        this.options = __assign({ skipOnError: true, logErrors: false }, options);
        // eslint-disable-next-line
        this.uglify = require(requireResolve('uglify-js', { cwd: this.options.servicePath }));
    }
    UglifyTransform.prototype.run = function (_a) {
        var code = _a.code, map = _a.map, filePath = _a.filePath;
        var fileName = path.basename(filePath);
        var result = { code: code, map: map };
        try {
            result = this.uglify.minify((_b = {}, _b[fileName] = code, _b), __assign({}, this.config, { 
                // Must pass through any previous source maps
                inSourceMap: map || null, outSourceMap: fileName + ".map", fromString: true }));
        }
        catch (err) {
            // tslint:disable-next-line:no-console
            if (this.options.logErrors) {
                console.error(err);
            } // eslint-disable-line
            if (!this.options.skipOnError) {
                throw err;
            }
        }
        return result;
        var _b;
    };
    return UglifyTransform;
}());
exports.UglifyTransform = UglifyTransform;
//# sourceMappingURL=Uglify.js.map